-- Initial schema migration
-- Created at: 2024-03-20 00:00:00 

-- #############################################################
-- ##          Phase 1: Updated Schema SQL (incorporating LWW & Locking) ##
-- #############################################################

-- Ensure Foreign Keys are enabled
PRAGMA foreign_keys = ON;

-- Use TEXT for Timestamps to store ISO8601 format with precision
-- Example: 'YYYY-MM-DDTHH:MM:SS.sssZ' (UTC is generally recommended for sync)
-- Using datetime('now', 'localtime') for defaults as per original schema, but consider UTC.

-- ----------- Users Table (with Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS users (
    id TEXT PRIMARY KEY, -- UUID

    email TEXT NOT NULL UNIQUE,
    email_updated_at TEXT,          -- Field timestamp (ISO8601 UTC preferably)
    email_updated_by TEXT,          -- Field author (user_id)

    password_hash TEXT NOT NULL,
    -- password_hash_updated_at: Not typically needed for LWW sync

    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,

    -- Assuming 'field_tl' is a valid role now for locking
    role TEXT NOT NULL CHECK (role IN ('admin', 'field_tl', 'field')),
    role_updated_at TEXT,
    role_updated_by TEXT,

    last_login TEXT DEFAULT NULL,
    -- last_login_updated_at: Info only, not for LWW merge usually

    active INTEGER NOT NULL DEFAULT 1, -- 1=true, 0=false
    active_updated_at TEXT,
    active_updated_by TEXT,

    -- Core Timestamps/Authorship for the record itself
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- ISO8601 UTC
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- Main record timestamp (reflects the latest field update time)
    created_by_user_id TEXT, -- User who created this user record
    updated_by_user_id TEXT, -- User who last touched any field on this record

    -- Optional Soft Delete fields (can also be inferred from 'delete' in change_log)
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (email_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (role_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (active_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_updated_at ON users(updated_at); -- Useful for general queries
CREATE INDEX IF NOT EXISTS idx_users_deleted_at ON users(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_users_created_by ON users(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_users_updated_by ON users(updated_by_user_id);


-- ----------- Status Types (Lookup Table - Now Syncable) -----------
CREATE TABLE IF NOT EXISTS status_types (
    id INTEGER PRIMARY KEY AUTOINCREMENT, -- Local immutable ID

    value TEXT NOT NULL UNIQUE,
    value_updated_at TEXT,          -- Timestamp for value change
    value_updated_by TEXT,          -- User who changed the value

    -- Core sync metadata
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When this status was added
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When value last changed or record soft deleted/undeleted
    created_by_user_id TEXT, -- User who added this status
    updated_by_user_id TEXT, -- User who last touched this record

    deleted_at TEXT DEFAULT NULL, -- If status types can be removed
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (value_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_status_types_value ON status_types(value);
CREATE INDEX IF NOT EXISTS idx_status_types_deleted_at ON status_types(deleted_at);

-- Initial seeding (still useful)
INSERT OR IGNORE INTO status_types (id, value, created_at, updated_at) VALUES
    (1, 'On Track', strftime('%Y-%m-%dT%H:%M:%fZ', 'now'), strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    (2, 'At Risk', strftime('%Y-%m-%dT%H:%M:%fZ', 'now'), strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    (3, 'Delayed', strftime('%Y-%m-%dT%H:%M:%fZ', 'now'), strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    (4, 'Completed', strftime('%Y-%m-%dT%H:%M:%fZ', 'now'), strftime('%Y-%m-%dT%H:%M:%fZ', 'now'));
-- NOTE: Explicit IDs used here for potentially easier referencing if needed, but AUTOINCREMENT is fine too.

-- ----------- Strategic Goals (with Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS strategic_goals (
    id TEXT PRIMARY KEY, -- UUID

    objective_code TEXT NOT NULL,
    objective_code_updated_at TEXT,
    objective_code_updated_by TEXT,

    outcome TEXT,
    outcome_updated_at TEXT,
    outcome_updated_by TEXT,

    kpi TEXT,
    kpi_updated_at TEXT,
    kpi_updated_by TEXT,

    target_value REAL,
    target_value_updated_at TEXT,
    target_value_updated_by TEXT,

    actual_value REAL DEFAULT 0,
    actual_value_updated_at TEXT,
    actual_value_updated_by TEXT,

    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,

    responsible_team TEXT,
    responsible_team_updated_at TEXT,
    responsible_team_updated_by TEXT,

    -- sync_status: Can be removed or repurposed. Let's remove for now, relying on change_log.
    -- last_updated: Redundant, use updated_at.

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for all _updated_by fields...
    FOREIGN KEY (objective_code_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcome_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (kpi_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (target_value_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (actual_value_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (responsible_team_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_strategic_goals_status ON strategic_goals(status_id);
CREATE INDEX IF NOT EXISTS idx_strategic_goals_updated_at ON strategic_goals(updated_at);
CREATE INDEX IF NOT EXISTS idx_strategic_goals_deleted_at ON strategic_goals(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_strategic_goals_created_by ON strategic_goals(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_strategic_goals_updated_by ON strategic_goals(updated_by_user_id);


-- ----------- Projects Table (with Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS projects (
    id TEXT PRIMARY KEY, -- UUID
    strategic_goal_id TEXT NOT NULL, -- This relationship itself might need update tracking if it can change

    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,

    objective TEXT,
    objective_updated_at TEXT,
    objective_updated_by TEXT,

    outcome TEXT,
    outcome_updated_at TEXT,
    outcome_updated_by TEXT,

    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,

    timeline TEXT,
    timeline_updated_at TEXT,
    timeline_updated_by TEXT,

    responsible_team TEXT,
    responsible_team_updated_at TEXT,
    responsible_team_updated_by TEXT,

    -- Removed last_updated, sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (strategic_goal_id) REFERENCES strategic_goals(id) ON DELETE CASCADE,
    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for all _updated_by fields...
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (objective_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcome_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (timeline_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (responsible_team_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_projects_strategic_goal ON projects(strategic_goal_id);
CREATE INDEX IF NOT EXISTS idx_projects_status ON projects(status_id);
CREATE INDEX IF NOT EXISTS idx_projects_updated_at ON projects(updated_at);
CREATE INDEX IF NOT EXISTS idx_projects_deleted_at ON projects(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_projects_created_by ON projects(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_projects_updated_by ON projects(updated_by_user_id);


-- ----------- Activities Table (Needs Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS activities (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,

    description TEXT,
    description_updated_at TEXT,
    description_updated_by TEXT,

    kpi TEXT,
    kpi_updated_at TEXT,
    kpi_updated_by TEXT,

    target_value REAL,
    target_value_updated_at TEXT,
    target_value_updated_by TEXT,

    actual_value REAL DEFAULT 0,
    actual_value_updated_at TEXT,
    actual_value_updated_by TEXT,

    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,

    -- Removed sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for _updated_by fields...
    FOREIGN KEY (description_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (kpi_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (target_value_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (actual_value_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_activities_project ON activities(project_id);
CREATE INDEX IF NOT EXISTS idx_activities_status ON activities(status_id);
CREATE INDEX IF NOT EXISTS idx_activities_updated_at ON activities(updated_at);
CREATE INDEX IF NOT EXISTS idx_activities_deleted_at ON activities(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_activities_created_by ON activities(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_activities_updated_by ON activities(updated_by_user_id);


-- ----------- Participants Table (with Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS participants (
    id TEXT PRIMARY KEY, -- UUID

    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,

    gender TEXT,
    gender_updated_at TEXT,
    gender_updated_by TEXT,

    disability INTEGER DEFAULT 0, -- 0=false, 1=true
    disability_updated_at TEXT,
    disability_updated_by TEXT,

    disability_type TEXT DEFAULT NULL,
    disability_type_updated_at TEXT,
    disability_type_updated_by TEXT,

    age_group TEXT,
    age_group_updated_at TEXT,
    age_group_updated_by TEXT,

    location TEXT, -- Consider linking to locations table via location_id TEXT?
    location_updated_at TEXT,
    location_updated_by TEXT,

    -- Removed sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for _updated_by fields...
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (gender_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (disability_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (disability_type_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (age_group_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (location_updated_by) REFERENCES users(id) ON DELETE SET NULL

);
CREATE INDEX IF NOT EXISTS idx_participants_location ON participants(location);
CREATE INDEX IF NOT EXISTS idx_participants_gender_age ON participants(gender, age_group);
CREATE INDEX IF NOT EXISTS idx_participants_updated_at ON participants(updated_at);
CREATE INDEX IF NOT EXISTS idx_participants_deleted_at ON participants(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_participants_created_by ON participants(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_participants_updated_by ON participants(updated_by_user_id);


-- ----------- Workshops Table (Needs Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS workshops (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,

    purpose TEXT,
    purpose_updated_at TEXT,
    purpose_updated_by TEXT,

    event_date TEXT,
    event_date_updated_at TEXT,
    event_date_updated_by TEXT,

    location TEXT, -- Link to locations table?
    location_updated_at TEXT,
    location_updated_by TEXT,

    budget REAL,
    budget_updated_at TEXT,
    budget_updated_by TEXT,

    actuals REAL,
    actuals_updated_at TEXT,
    actuals_updated_by TEXT,

    participant_count INTEGER DEFAULT 0, -- This might be derived or needs specific update logic
    participant_count_updated_at TEXT,
    participant_count_updated_by TEXT,

    local_partner TEXT, -- Link to partners table?
    local_partner_updated_at TEXT,
    local_partner_updated_by TEXT,

    partner_responsibility TEXT,
    partner_responsibility_updated_at TEXT,
    partner_responsibility_updated_by TEXT,

    -- Fields likely filled post-event, still need LWW tracking
    partnership_success TEXT,
    partnership_success_updated_at TEXT,
    partnership_success_updated_by TEXT,
    capacity_challenges TEXT,
    capacity_challenges_updated_at TEXT,
    capacity_challenges_updated_by TEXT,
    strengths TEXT,
    strengths_updated_at TEXT,
    strengths_updated_by TEXT,
    outcomes TEXT,
    outcomes_updated_at TEXT,
    outcomes_updated_by TEXT,
    recommendations TEXT,
    recommendations_updated_at TEXT,
    recommendations_updated_by TEXT,
    challenge_resolution TEXT,
    challenge_resolution_updated_at TEXT,
    challenge_resolution_updated_by TEXT,

    -- Removed sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (participant_count_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for all _updated_by fields...
    FOREIGN KEY (purpose_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (event_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (location_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (budget_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (actuals_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (local_partner_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (partner_responsibility_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (partnership_success_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (capacity_challenges_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (strengths_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcomes_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (recommendations_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (challenge_resolution_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_workshops_project ON workshops(project_id);
CREATE INDEX IF NOT EXISTS idx_workshops_event_date ON workshops(event_date);
CREATE INDEX IF NOT EXISTS idx_workshops_location ON workshops(location);
CREATE INDEX IF NOT EXISTS idx_workshops_updated_at ON workshops(updated_at);
CREATE INDEX IF NOT EXISTS idx_workshops_deleted_at ON workshops(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_workshops_created_by ON workshops(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_workshops_updated_by ON workshops(updated_by_user_id);


-- ----------- Workshop Participants (Junction Table) -----------
-- Junction tables typically track the existence of a relationship.
-- If the relationship itself is the unit of change (added/removed), LWW applies to the record.
CREATE TABLE IF NOT EXISTS workshop_participants (
    id TEXT PRIMARY KEY, -- UUID for the relationship instance
    workshop_id TEXT NOT NULL,
    participant_id TEXT NOT NULL,

    pre_evaluation TEXT,
    pre_evaluation_updated_at TEXT,
    pre_evaluation_updated_by TEXT,

    post_evaluation TEXT,
    post_evaluation_updated_at TEXT,
    post_evaluation_updated_by TEXT,

    -- Removed sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When relationship was added
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When evaluation fields were last updated
    created_by_user_id TEXT, -- User who added the participant
    updated_by_user_id TEXT, -- User who last updated evaluation

    deleted_at TEXT DEFAULT NULL, -- When relationship was removed (soft delete)
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (workshop_id) REFERENCES workshops(id) ON DELETE CASCADE,
    FOREIGN KEY (participant_id) REFERENCES participants(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (pre_evaluation_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (post_evaluation_updated_by) REFERENCES users(id) ON DELETE SET NULL,

    UNIQUE(workshop_id, participant_id) -- Ensures a participant isn't added twice to the same workshop
);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_workshop ON workshop_participants(workshop_id);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_participant ON workshop_participants(participant_id);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_updated_at ON workshop_participants(updated_at);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_deleted_at ON workshop_participants(deleted_at);


-- ----------- Livelihoods Table (Needs Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS livelihoods (
    id TEXT PRIMARY KEY,
    participant_id TEXT NOT NULL,
    project_id TEXT NOT NULL,

    grant_amount REAL, 
    grant_amount_updated_at TEXT,
    grant_amount_updated_by TEXT,

    purpose TEXT,
    purpose_updated_at TEXT,
    purpose_updated_by TEXT,

    progress1 TEXT,
    progress1_updated_at TEXT,
    progress1_updated_by TEXT,

    progress2 TEXT,
    progress2_updated_at TEXT,
    progress2_updated_by TEXT,

    outcome TEXT,
    outcome_updated_at TEXT,
    outcome_updated_by TEXT,

    -- Removed sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (participant_id) REFERENCES participants(id) ON DELETE CASCADE,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for _updated_by fields...
    FOREIGN KEY (grant_amount_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (purpose_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (progress1_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (progress2_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcome_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_livelihoods_participant ON livelihoods(participant_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_project ON livelihoods(project_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_updated_at ON livelihoods(updated_at);
CREATE INDEX IF NOT EXISTS idx_livelihoods_deleted_at ON livelihoods(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_livelihoods_created_by ON livelihoods(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_updated_by ON livelihoods(updated_by_user_id);


-- ----------- Subsequent Grants Table (Needs Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS subsequent_grants (
    id TEXT PRIMARY KEY,
    livelihood_id TEXT NOT NULL,

    amount REAL,
    amount_updated_at TEXT,
    amount_updated_by TEXT,

    purpose TEXT,
    purpose_updated_at TEXT,
    purpose_updated_by TEXT,

    grant_date TEXT,
    grant_date_updated_at TEXT,
    grant_date_updated_by TEXT,

    -- Removed sync_status

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (livelihood_id) REFERENCES livelihoods(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for _updated_by fields...
    FOREIGN KEY (amount_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (purpose_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (grant_date_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
CREATE INDEX IF NOT EXISTS idx_subsequent_grants_livelihood ON subsequent_grants(livelihood_id);
CREATE INDEX IF NOT EXISTS idx_subsequent_grants_date ON subsequent_grants(grant_date);
CREATE INDEX IF NOT EXISTS idx_subsequent_grants_updated_at ON subsequent_grants(updated_at);
CREATE INDEX IF NOT EXISTS idx_subsequent_grants_deleted_at ON subsequent_grants(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_subsequent_grants_created_by ON subsequent_grants(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_subsequent_grants_updated_by ON subsequent_grants(updated_by_user_id);


-- ----------- Donors Table (with Field Timestamps & Authors) -----------
CREATE TABLE IF NOT EXISTS donors (
    id TEXT PRIMARY KEY, -- UUID

    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,

    type TEXT, -- e.g., 'Individual', 'Foundation', 'Government', 'Corporate'
    type_updated_at TEXT,
    type_updated_by TEXT,

    contact_person TEXT,
    contact_person_updated_at TEXT,
    contact_person_updated_by TEXT,

    email TEXT,
    email_updated_at TEXT,
    email_updated_by TEXT,

    phone TEXT,
    phone_updated_at TEXT,
    phone_updated_by TEXT,

    country TEXT, -- Consider linking to locations table?
    country_updated_at TEXT,
    country_updated_by TEXT,

    first_donation_date TEXT, -- ISO date string
    first_donation_date_updated_at TEXT,
    first_donation_date_updated_by TEXT,

    notes TEXT,
    notes_updated_at TEXT,
    notes_updated_by TEXT,

    -- Core sync metadata
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,

    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for all _updated_by fields...
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (type_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (contact_person_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (email_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (phone_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (country_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (first_donation_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (notes_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_donors_name ON donors(name);
CREATE INDEX IF NOT EXISTS idx_donors_type ON donors(type);
CREATE INDEX IF NOT EXISTS idx_donors_country ON donors(country); -- Add if querying by country
CREATE INDEX IF NOT EXISTS idx_donors_updated_at ON donors(updated_at);
CREATE INDEX IF NOT EXISTS idx_donors_deleted_at ON donors(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_donors_created_by ON donors(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_donors_updated_by ON donors(updated_by_user_id);






-- ----------- Project Funding Table (with Field Timestamps & Authors) -----------
-- This table links Projects and Donors, tracking specific funding instances.
CREATE TABLE IF NOT EXISTS project_funding (
    id TEXT PRIMARY KEY, -- UUID for this specific funding record

    project_id TEXT NOT NULL,
    project_id_updated_at TEXT,     -- If funding can be re-assigned (less common)
    project_id_updated_by TEXT,

    donor_id TEXT NOT NULL,
    donor_id_updated_at TEXT,       -- If donor can be corrected
    donor_id_updated_by TEXT,

    grant_id TEXT,                  -- Reference number for the grant
    grant_id_updated_at TEXT,
    grant_id_updated_by TEXT,

    amount REAL,
    amount_updated_at TEXT,
    amount_updated_by TEXT,

    currency TEXT DEFAULT 'AUD',
    currency_updated_at TEXT,
    currency_updated_by TEXT,

    start_date TEXT,                -- ISO date string 'YYYY-MM-DD'
    start_date_updated_at TEXT,
    start_date_updated_by TEXT,

    end_date TEXT,                  -- ISO date string 'YYYY-MM-DD'
    end_date_updated_at TEXT,
    end_date_updated_by TEXT,

    status TEXT,                    -- e.g., 'Committed', 'Received', 'Pending', 'Completed'
    status_updated_at TEXT,
    status_updated_by TEXT,

    reporting_requirements TEXT,
    reporting_requirements_updated_at TEXT,
    reporting_requirements_updated_by TEXT,

    notes TEXT,
    notes_updated_at TEXT,
    notes_updated_by TEXT,

    -- Core sync metadata
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When this funding record was created
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When any field on this record was last updated
    created_by_user_id TEXT, -- User who entered this funding record
    updated_by_user_id TEXT, -- User who last modified this funding record

    deleted_at TEXT DEFAULT NULL, -- If funding records can be soft-deleted
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE, -- If project deleted, funding record might be irrelevant
    FOREIGN KEY (donor_id) REFERENCES donors(id) ON DELETE RESTRICT, -- Don't delete donor if they have funding attached
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for all _updated_by fields...
    FOREIGN KEY (project_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (donor_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (grant_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (amount_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (currency_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (start_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (end_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (reporting_requirements_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (notes_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Indices for common query patterns
CREATE INDEX IF NOT EXISTS idx_project_funding_project ON project_funding(project_id);
CREATE INDEX IF NOT EXISTS idx_project_funding_donor ON project_funding(donor_id);
CREATE INDEX IF NOT EXISTS idx_project_funding_status ON project_funding(status); -- If filtering by status
CREATE INDEX IF NOT EXISTS idx_project_funding_updated_at ON project_funding(updated_at);
CREATE INDEX IF NOT EXISTS idx_project_funding_deleted_at ON project_funding(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_project_funding_created_by ON project_funding(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_project_funding_updated_by ON project_funding(updated_by_user_id);




-- ----------- Document Types Table (Syncable Configuration) -----------
-- Defines the types of documents allowed, their properties, and compression settings.
-- Made syncable to allow adding/editing types post-deployment.
CREATE TABLE IF NOT EXISTS document_types (
    id TEXT PRIMARY KEY, -- User-defined key, e.g., 'receipt', 'project_plan', 'photo_evidence'

    name TEXT NOT NULL,              -- Display name, e.g., "Receipt", "Project Plan"
    name_updated_at TEXT,
    name_updated_by TEXT,

    allowed_extensions TEXT NOT NULL, -- Comma-separated list: 'jpg,png,pdf'
    allowed_extensions_updated_at TEXT,
    allowed_extensions_updated_by TEXT,

    max_size INTEGER NOT NULL,       -- Maximum file size in bytes
    max_size_updated_at TEXT,
    max_size_updated_by TEXT,

    compression_level INTEGER NOT NULL DEFAULT 6, -- 0-9 (0=none, 9=max)
    compression_level_updated_at TEXT,
    compression_level_updated_by TEXT,

    compression_method TEXT DEFAULT 'default', -- 'default', 'lossless', 'lossy', 'none'
    compression_method_updated_at TEXT,
    compression_method_updated_by TEXT,

    min_size_for_compression INTEGER DEFAULT 10240, -- Don't compress if smaller (bytes)
    min_size_for_compression_updated_at TEXT,
    min_size_for_compression_updated_by TEXT,

    description TEXT,               -- Usage guidance for the type
    description_updated_at TEXT,
    description_updated_by TEXT,

    default_priority TEXT NOT NULL DEFAULT 'normal' CHECK(default_priority IN ('high', 'normal', 'low', 'never')), -- Sync priority hint
    default_priority_updated_at TEXT,
    default_priority_updated_by TEXT,

    icon TEXT,                      -- Icon identifier for UI (e.g., 'file-pdf', 'image')
    icon_updated_at TEXT,
    icon_updated_by TEXT,

    related_tables TEXT,            -- JSON array of table names where this type is typically used (for UI hints/filtering)
    related_tables_updated_at TEXT,
    related_tables_updated_by TEXT,

    -- Core sync metadata
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT, -- User who defined this type
    updated_by_user_id TEXT, -- User who last modified this type definition

    deleted_at TEXT DEFAULT NULL, -- If document types can be deactivated/hidden
    deleted_by_user_id TEXT DEFAULT NULL,

    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    -- Add FKs for all _updated_by fields...
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (allowed_extensions_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (max_size_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (compression_level_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (compression_method_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (min_size_for_compression_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (description_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (default_priority_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (icon_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (related_tables_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Indices
CREATE UNIQUE INDEX IF NOT EXISTS idx_document_types_name ON document_types(name) WHERE deleted_at IS NULL; -- Unique active names
CREATE INDEX IF NOT EXISTS idx_document_types_updated_at ON document_types(updated_at);
CREATE INDEX IF NOT EXISTS idx_document_types_deleted_at ON document_types(deleted_at);

-- Add indexes for user tracking columns across all entity tables
CREATE INDEX IF NOT EXISTS idx_document_types_created_by ON document_types(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_document_types_updated_by ON document_types(updated_by_user_id);


-- ----------- Media/Documents Table (Needs Field Timestamps & Authors for mutable metadata) -----------
CREATE TABLE IF NOT EXISTS media_documents (
    id TEXT PRIMARY KEY NOT NULL,
    related_table TEXT NOT NULL,
    related_id TEXT NOT NULL,
    type_id TEXT NOT NULL,
    file_path TEXT NOT NULL,
    original_filename TEXT NOT NULL,
    title TEXT NULL,
    mime_type TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    field_identifier TEXT NULL,
    compression_status TEXT NOT NULL DEFAULT 'pending',
    compressed_file_path TEXT NULL,
    blob_sync_status TEXT NOT NULL DEFAULT 'pending',
    blob_storage_key TEXT NULL,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT NULL,
    updated_by_user_id TEXT NULL,
    deleted_at TEXT NULL,
    deleted_by_user_id TEXT NULL,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (type_id) REFERENCES document_types(id) ON DELETE RESTRICT
);
CREATE INDEX IF NOT EXISTS idx_media_documents_related ON media_documents(related_table, related_id);
CREATE INDEX IF NOT EXISTS idx_media_documents_type ON media_documents(type_id);
CREATE INDEX IF NOT EXISTS idx_media_documents_user ON media_documents(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_media_documents_compression ON media_documents(compression_status);
CREATE INDEX IF NOT EXISTS idx_media_documents_blob_sync ON media_documents(blob_sync_status);
CREATE INDEX IF NOT EXISTS idx_media_documents_updated_at ON media_documents(updated_at);
CREATE INDEX IF NOT EXISTS idx_media_documents_deleted_at ON media_documents(deleted_at);


-- ----------- Document Versions Table (Local Log) -----------
-- Tracks the history of specific document files (original, compressed versions) locally.
-- This table itself is not typically synced between devices via LWW.
CREATE TABLE IF NOT EXISTS document_versions (
    id TEXT PRIMARY KEY,                -- UUID for this version entry
    document_id TEXT NOT NULL,          -- FK to media_documents.id
    version_number INTEGER NOT NULL,    -- Sequential version number (e.g., 1, 2, 3...)
    file_path TEXT NOT NULL,            -- Path to the file for this version (could be original or compressed)
    file_size INTEGER,                  -- Size of the file at this version
    is_compressed INTEGER DEFAULT 0,    -- 1 if this version represents a compressed file, 0 otherwise
    change_type TEXT NOT NULL CHECK(change_type IN ('original', 'compressed', 'modified', 'restored')), -- What action led to this version
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When this version record was created
    created_by_user_id TEXT,            -- User associated with the action creating this version

    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE, -- If document deleted, history goes too
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL
);

-- Indices
CREATE INDEX IF NOT EXISTS idx_document_versions_document ON document_versions(document_id);
CREATE INDEX IF NOT EXISTS idx_document_versions_created_at ON document_versions(created_at); -- For ordering history





-- ----------- Document Access Logs Table (Local Audit Log) -----------
-- Records access events (view, download, etc.) for documents on the local device.
-- Not synced between devices.
CREATE TABLE IF NOT EXISTS document_access_logs (
    id TEXT PRIMARY KEY,                -- UUID for the log entry
    document_id TEXT NOT NULL,          -- FK to media_documents.id
    user_id TEXT NOT NULL,              -- FK to users.id (who accessed)
    access_type TEXT NOT NULL CHECK(access_type IN ('view', 'download', 'edit_metadata', 'delete', 'print')), -- Type of access
    access_date TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- Timestamp of access
    details TEXT,                       -- Optional JSON for extra info (e.g., IP if relevant, success/fail)

    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE, -- If doc deleted, access log may remain or cascade? Cascade seems ok.
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE -- If user deleted, their access log remains (cascade ok)
);

-- Indices
CREATE INDEX IF NOT EXISTS idx_document_access_logs_document ON document_access_logs(document_id);
CREATE INDEX IF NOT EXISTS idx_document_access_logs_user ON document_access_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_document_access_logs_date ON document_access_logs(access_date);



-- ----------- Compression Queue Table (Local State) -----------
-- Manages the queue of documents needing background compression on this device.
-- Not synced.
CREATE TABLE IF NOT EXISTS compression_queue (
    id TEXT PRIMARY KEY,                -- UUID for the queue entry
    document_id TEXT NOT NULL UNIQUE,   -- FK to media_documents.id (Only one queue entry per doc)
    priority INTEGER DEFAULT 5,         -- Priority for processing (higher value = higher priority)
    attempts INTEGER DEFAULT 0,         -- Number of times processing was attempted
    status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'completed', 'failed')), -- Current status
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When added to queue
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When status/attempts last changed
    error_message TEXT,                 -- Stores error if status is 'failed'

    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE -- If document deleted, remove from queue
);

-- Indices
-- Index for finding pending tasks, ordered by priority and age
CREATE INDEX IF NOT EXISTS idx_compression_queue_pending ON compression_queue(status, priority DESC, created_at ASC) WHERE status = 'pending';
CREATE INDEX IF NOT EXISTS idx_compression_queue_document ON compression_queue(document_id); -- Covered by UNIQUE constraint


-- ----------- Compression Stats Table (Local Aggregated State) -----------
-- Stores aggregated statistics about file compression performed on this device.
-- Not synced.
CREATE TABLE IF NOT EXISTS compression_stats (
    id TEXT PRIMARY KEY CHECK(id = 'global'), -- Singleton row
    total_original_size BIGINT DEFAULT 0,    -- Sum of original sizes of compressed files
    total_compressed_size BIGINT DEFAULT 0,  -- Sum of compressed sizes
    space_saved BIGINT DEFAULT 0,            -- Difference: original - compressed
    compression_ratio REAL DEFAULT 0,        -- Average ratio: (space_saved / total_original_size) * 100
    total_files_compressed INTEGER DEFAULT 0,-- Count of successfully compressed files
    total_files_pending INTEGER DEFAULT 0,   -- Current count of files in the compression queue (status='pending')
    total_files_failed INTEGER DEFAULT 0,    -- Count of files that failed compression
    last_compression_date TEXT,              -- Timestamp of the last successful compression
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')) -- When stats were last updated
);

-- Insert the singleton row if it doesn't exist
INSERT OR IGNORE INTO compression_stats (id) VALUES ('global');


-- ----------- App Settings Table (Needs LWW if settings are synced) -----------
CREATE TABLE IF NOT EXISTS app_settings (
    id TEXT PRIMARY KEY CHECK(id = 'global'), -- Singleton

    compression_enabled INTEGER DEFAULT 1,
    compression_enabled_updated_at TEXT,
    compression_enabled_updated_by TEXT,

    default_compression_timing TEXT DEFAULT 'immediate' CHECK(default_compression_timing IN ('immediate', 'background', 'manual')),
    default_compression_timing_updated_at TEXT,
    default_compression_timing_updated_by TEXT,

    background_service_interval INTEGER DEFAULT 300,
    background_service_interval_updated_at TEXT,
    background_service_interval_updated_by TEXT,

    -- Other settings... add _updated_at / _updated_by if they need to be synced via LWW

    last_background_run TEXT, -- Local state, not synced

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- Should only happen once
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- Metadata record updated
    created_by_user_id TEXT, -- Who initially set up settings?
    updated_by_user_id TEXT, -- Who last changed a synced setting

    -- Add FKs for _updated_by fields...
    FOREIGN KEY (compression_enabled_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (default_compression_timing_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (background_service_interval_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
INSERT OR IGNORE INTO app_settings (id) VALUES ('global');


-- ----------- Sync Settings Table (User-specific, needs LWW) -----------
CREATE TABLE IF NOT EXISTS sync_settings (
    user_id TEXT PRIMARY KEY,

    max_file_size INTEGER DEFAULT 10485760,
    max_file_size_updated_at TEXT,
    max_file_size_updated_by TEXT,

    compression_enabled INTEGER DEFAULT 1,
    compression_enabled_updated_at TEXT,
    compression_enabled_updated_by TEXT,

    compression_timing TEXT DEFAULT 'immediate' CHECK(compression_timing IN ('immediate', 'background', 'manual')),
    compression_timing_updated_at TEXT,
    compression_timing_updated_by TEXT,

    -- Other settings... add _updated_at / _updated_by

    -- Removed last_updated (use updated_at)

    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When prefs created for user
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')), -- When prefs last updated
    -- No created_by/updated_by needed, it's the user_id itself

    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    -- Add FKs for _updated_by fields (referencing users.id)...
    FOREIGN KEY (max_file_size_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (compression_enabled_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (compression_timing_updated_by) REFERENCES users(id) ON DELETE SET NULL
);


-- #############################################################
-- ##          NEW TABLES FOR SYNC AND LOCKING                ##
-- #############################################################

-- ----------- Change Log Table (Tracks specific changes for sync) -----------
CREATE TABLE IF NOT EXISTS change_log (
    operation_id TEXT PRIMARY KEY, -- Unique ID for this specific change event (UUID)
    entity_table TEXT NOT NULL,    -- e.g., 'users', 'projects'
    entity_id TEXT NOT NULL,       -- The ID of the record changed
    operation_type TEXT NOT NULL CHECK (operation_type IN (
        'create',       -- Record created
        'update',       -- Field updated
        'delete'        -- Record soft deleted (set deleted_at)
     )),
    field_name TEXT,               -- Field name for 'update'. NULL otherwise.
    old_value TEXT,                -- Optional: Previous value (JSON encoded) for auditing/debugging
    new_value TEXT,                -- New value (JSON encoded) for 'create', 'update'. NULL for delete.
    timestamp TEXT NOT NULL,       -- High precision ISO8601 UTC timestamp of the change
    user_id TEXT NOT NULL,         -- User performing the change
    device_id TEXT,                -- Optional: ID of the device making the change

    -- Sync processing state
    sync_batch_id TEXT,            -- ID of the sync batch this belongs to (upload or download)
    processed_at TEXT,             -- Timestamp when this incoming change was merged locally
    sync_error TEXT,               -- If processing failed

    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL, -- User might be deleted later
    FOREIGN KEY (sync_batch_id) REFERENCES sync_batches(batch_id) ON DELETE SET NULL -- Link to sync batch
);
CREATE INDEX IF NOT EXISTS idx_change_log_entity ON change_log(entity_table, entity_id);
CREATE INDEX IF NOT EXISTS idx_change_log_timestamp_user ON change_log(timestamp, user_id);
CREATE INDEX IF NOT EXISTS idx_change_log_unprocessed_for_upload ON change_log(sync_batch_id) WHERE sync_batch_id IS NULL AND processed_at IS NULL; -- Find changes to upload
CREATE INDEX IF NOT EXISTS idx_change_log_operation ON change_log(operation_type);
CREATE INDEX IF NOT EXISTS idx_change_log_batch ON change_log(sync_batch_id);

-- Fix the change_log partial index for finding upload candidates
DROP INDEX IF EXISTS idx_change_log_unprocessed_for_upload;
CREATE INDEX IF NOT EXISTS idx_change_log_unprocessed_for_upload 
ON change_log(entity_table, entity_id, timestamp) 
WHERE sync_batch_id IS NULL AND processed_at IS NULL;

/*
-- ----------- Locks Table (Tracks active locks) -----------
CREATE TABLE IF NOT EXISTS locks (
    id TEXT PRIMARY KEY,              -- Unique ID for the lock itself (UUID)
    entity_table TEXT NOT NULL,       -- e.g., 'users', 'projects'
    entity_id TEXT NOT NULL,          -- The ID of the record being locked
    field_name TEXT DEFAULT NULL,     -- Specific field locked (NULL means lock the whole record)

    lock_level TEXT NOT NULL CHECK (lock_level IN ('admin', 'field_tl')), -- Role level that *owns* this lock
    lock_reason TEXT,                 -- Optional reason for the lock

    -- LWW metadata for the lock itself
    locked_at TEXT NOT NULL,          -- High precision ISO8601 UTC timestamp when lock was applied/updated
    locked_by TEXT NOT NULL,          -- user_id who applied/updated the lock

    -- Unique constraint to prevent conflicting locks on the exact same target
    -- A record lock (field_name IS NULL) prevents field locks, and vice-versa implicitly by checks.
    UNIQUE (entity_table, entity_id, field_name)
);
CREATE INDEX IF NOT EXISTS idx_locks_target ON locks(entity_table, entity_id, field_name); -- Fast checking
CREATE INDEX IF NOT EXISTS idx_locks_user ON locks(locked_by);
CREATE INDEX IF NOT EXISTS idx_locks_timestamp ON locks(locked_at); -- For LWW resolution on the lock itself
*/

-- ----------- Sync Batches Table (Manages upload/download batches) -----------
-- Replaces the old complex sync_queue
CREATE TABLE IF NOT EXISTS sync_batches (
    batch_id TEXT PRIMARY KEY,          -- UUID for the batch
    direction TEXT NOT NULL CHECK (direction IN ('upload', 'download')),
    status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'completed', 'failed', 'partially_failed')),
    item_count INTEGER DEFAULT 0,       -- Number of change_log entries included
    total_size INTEGER DEFAULT 0,       -- Estimated size for network awareness
    priority INTEGER DEFAULT 5,         -- Maybe influence order of processing
    attempts INTEGER DEFAULT 0,
    last_attempt_at TEXT,
    error_message TEXT,                 -- Summary error if batch failed
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    completed_at TEXT
);
CREATE INDEX IF NOT EXISTS idx_sync_batches_status_priority ON sync_batches(status, priority, created_at);
CREATE INDEX IF NOT EXISTS idx_sync_batches_direction ON sync_batches(direction, status);

-- Add FK constraint from change_log to sync_batches now that it's defined
-- Note: SQLite doesn't support ADD CONSTRAINT directly after table creation easily.
-- Usually handled by migration tools or recreating table. Assume it's handled.
-- ALTER TABLE change_log ADD CONSTRAINT fk_change_log_batch FOREIGN KEY (sync_batch_id) REFERENCES sync_batches(batch_id) ON DELETE SET NULL;



-- ----------- Audit Logs (Revised slightly) -----------
-- Kept for non-sync specific auditing. Actions expanded.
CREATE TABLE IF NOT EXISTS audit_logs (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    action TEXT NOT NULL CHECK (action IN (
        'create', 'update', 'delete', -- Corresponds to change_log operations
        'login_success', 'login_fail', 'logout', -- Auth events
        'sync_upload_start', 'sync_upload_complete', 'sync_upload_fail', -- Sync events
        'sync_download_start', 'sync_download_complete', 'sync_download_fail',
        'merge_conflict_resolved', 'merge_conflict_detected', -- Sync details
        'permission_denied', 'data_export', 'data_import' -- Other actions
        )),
    entity_table TEXT, -- Table related to action (users, projects...)
    entity_id TEXT,    -- Record ID related to action
    field_name TEXT,   -- Field related to action (if applicable)
    details TEXT,      -- JSON blob for extra context (e.g., error msg, IP address, change diff summary)
    timestamp TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE -- Audit remains even if user deleted? Maybe SET NULL?
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target ON audit_logs(entity_table, entity_id);




-- #############################################################
-- ##          REVISED TRIGGERS (Example - App Logic Recommended) ##
-- #############################################################

-- Note: Change logging and related operations are handled at the application level
-- in the Rust code for better atomicity, context access, and maintainability.
-- This is preferred over database triggers for this use case.

-- Example of how complex triggers would get (for reference only):
/*
CREATE TRIGGER after_user_update_generate_changelog
AFTER UPDATE ON users
WHEN OLD.updated_at <> NEW.updated_at -- Only log actual updates
BEGIN
    -- Log email change
    INSERT INTO change_log (operation_id, entity_table, entity_id, operation_type, field_name, old_value, new_value, timestamp, user_id, device_id)
    SELECT lower(hex(randomblob(16))), 'users', NEW.id, 'update', 'email', json_quote(OLD.email), json_quote(NEW.email), NEW.email_updated_at, NEW.email_updated_by, NULL -- device_id unavailable here
    WHERE OLD.email IS NOT NEW.email; -- Check null safety

    -- Log name change
    INSERT INTO change_log (operation_id, entity_table, entity_id, operation_type, field_name, old_value, new_value, timestamp, user_id, device_id)
    SELECT lower(hex(randomblob(16))), 'users', NEW.id, 'update', 'name', json_quote(OLD.name), json_quote(NEW.name), NEW.name_updated_at, NEW.name_updated_by, NULL
    WHERE OLD.name IS NOT NEW.name;

    -- Log role change
    INSERT INTO change_log (operation_id, entity_table, entity_id, operation_type, field_name, old_value, new_value, timestamp, user_id, device_id)
    SELECT lower(hex(randomblob(16))), 'users', NEW.id, 'update', 'role', json_quote(OLD.role), json_quote(NEW.role), NEW.role_updated_at, NEW.role_updated_by, NULL
    WHERE OLD.role IS NOT NEW.role;

    -- Log active change
    INSERT INTO change_log (operation_id, entity_table, entity_id, operation_type, field_name, old_value, new_value, timestamp, user_id, device_id)
    SELECT lower(hex(randomblob(16))), 'users', NEW.id, 'update', 'active', json_quote(OLD.active), json_quote(NEW.active), NEW.active_updated_at, NEW.active_updated_by, NULL
    WHERE OLD.active IS NOT NEW.active;

    -- Trigger for soft delete
    INSERT INTO change_log (operation_id, entity_table, entity_id, operation_type, field_name, old_value, new_value, timestamp, user_id, device_id)
    SELECT lower(hex(randomblob(16))), 'users', NEW.id, 'delete', NULL, NULL, NULL, NEW.deleted_at, NEW.deleted_by_user_id, NULL
    WHERE OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL;

    -- Add similar INSERTs for other fields and other tables... this gets HUGE!
END;
*/

-- Recommendation: Implement change_log population in Rust application/repository layer
-- within the same transaction as the main table modification for guaranteed atomicity
-- and easier access to context like device_id.

-- Index on strategic_goals objective_code
CREATE INDEX IF NOT EXISTS idx_strategic_goals_objective_code ON strategic_goals(objective_code);

-- Indexes on name fields and other key text fields for searching/sorting
CREATE INDEX IF NOT EXISTS idx_users_name ON users(name);
CREATE INDEX IF NOT EXISTS idx_projects_name ON projects(name);
CREATE INDEX IF NOT EXISTS idx_participants_name ON participants(name);
CREATE INDEX IF NOT EXISTS idx_donors_name ON donors(name);
CREATE INDEX IF NOT EXISTS idx_document_types_name ON document_types(name);

-- Updated Schema Migration
-- Created at: 2025-04-04 
-- Based on original schema from 2024-03-20
-- With foreign key constraint updates

-- Enable foreign keys
PRAGMA foreign_keys = OFF;

-- #############################################################
-- ##          Phase 1: Update Foreign Key Constraints         ##
-- #############################################################

-- 1. For projects table (change CASCADE to RESTRICT for strategic_goal_id)
CREATE TABLE projects_new (
    id TEXT PRIMARY KEY,
    strategic_goal_id TEXT NOT NULL,
    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,
    objective TEXT,
    objective_updated_at TEXT,
    objective_updated_by TEXT,
    outcome TEXT,
    outcome_updated_at TEXT,
    outcome_updated_by TEXT,
    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,
    timeline TEXT,
    timeline_updated_at TEXT,
    timeline_updated_by TEXT,
    responsible_team TEXT,
    responsible_team_updated_at TEXT,
    responsible_team_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    -- Change CASCADE to RESTRICT for strategic_goal_id
    FOREIGN KEY (strategic_goal_id) REFERENCES strategic_goals(id) ON DELETE RESTRICT,
    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (objective_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcome_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (timeline_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (responsible_team_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Copy data from old table to new table
INSERT INTO projects_new SELECT * FROM projects;

-- Drop the old table
DROP TABLE projects;

-- Rename the new table to the original name
ALTER TABLE projects_new RENAME TO projects;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_projects_strategic_goal ON projects(strategic_goal_id);
CREATE INDEX IF NOT EXISTS idx_projects_status ON projects(status_id);
CREATE INDEX IF NOT EXISTS idx_projects_updated_at ON projects(updated_at);
CREATE INDEX IF NOT EXISTS idx_projects_deleted_at ON projects(deleted_at);
CREATE INDEX IF NOT EXISTS idx_projects_created_by ON projects(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_projects_updated_by ON projects(updated_by_user_id);
CREATE INDEX IF NOT EXISTS idx_projects_name ON projects(name);

-- 2. For workshops table (change CASCADE to RESTRICT for project_id)
CREATE TABLE workshops_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    purpose TEXT,
    purpose_updated_at TEXT,
    purpose_updated_by TEXT,
    event_date TEXT,
    event_date_updated_at TEXT,
    event_date_updated_by TEXT,
    location TEXT,
    location_updated_at TEXT,
    location_updated_by TEXT,
    budget REAL,
    budget_updated_at TEXT,
    budget_updated_by TEXT,
    actuals REAL,
    actuals_updated_at TEXT,
    actuals_updated_by TEXT,
    participant_count INTEGER DEFAULT 0,
    participant_count_updated_at TEXT,
    participant_count_updated_by TEXT,
    local_partner TEXT,
    local_partner_updated_at TEXT,
    local_partner_updated_by TEXT,
    partner_responsibility TEXT,
    partner_responsibility_updated_at TEXT,
    partner_responsibility_updated_by TEXT,
    partnership_success TEXT,
    partnership_success_updated_at TEXT,
    partnership_success_updated_by TEXT,
    capacity_challenges TEXT,
    capacity_challenges_updated_at TEXT,
    capacity_challenges_updated_by TEXT,
    strengths TEXT,
    strengths_updated_at TEXT,
    strengths_updated_by TEXT,
    outcomes TEXT,
    outcomes_updated_at TEXT,
    outcomes_updated_by TEXT,
    recommendations TEXT,
    recommendations_updated_at TEXT,
    recommendations_updated_by TEXT,
    challenge_resolution TEXT,
    challenge_resolution_updated_at TEXT,
    challenge_resolution_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    -- Change CASCADE to RESTRICT for project_id
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (participant_count_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (purpose_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (event_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (location_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (budget_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (actuals_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (local_partner_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (partner_responsibility_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (partnership_success_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (capacity_challenges_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (strengths_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcomes_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (recommendations_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (challenge_resolution_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

INSERT INTO workshops_new SELECT * FROM workshops;
DROP TABLE workshops;
ALTER TABLE workshops_new RENAME TO workshops;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_workshops_project ON workshops(project_id);
CREATE INDEX IF NOT EXISTS idx_workshops_event_date ON workshops(event_date);
CREATE INDEX IF NOT EXISTS idx_workshops_location ON workshops(location);
CREATE INDEX IF NOT EXISTS idx_workshops_updated_at ON workshops(updated_at);
CREATE INDEX IF NOT EXISTS idx_workshops_deleted_at ON workshops(deleted_at);
CREATE INDEX IF NOT EXISTS idx_workshops_created_by ON workshops(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_workshops_updated_by ON workshops(updated_by_user_id);

-- 3. For project_funding table (change CASCADE to RESTRICT for project_id)
CREATE TABLE project_funding_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    project_id_updated_at TEXT,
    project_id_updated_by TEXT,
    donor_id TEXT NOT NULL,
    donor_id_updated_at TEXT,
    donor_id_updated_by TEXT,
    grant_id TEXT,
    grant_id_updated_at TEXT,
    grant_id_updated_by TEXT,
    amount REAL,
    amount_updated_at TEXT,
    amount_updated_by TEXT,
    currency TEXT DEFAULT 'AUD',
    currency_updated_at TEXT,
    currency_updated_by TEXT,
    start_date TEXT,
    start_date_updated_at TEXT,
    start_date_updated_by TEXT,
    end_date TEXT,
    end_date_updated_at TEXT,
    end_date_updated_by TEXT,
    status TEXT,
    status_updated_at TEXT,
    status_updated_by TEXT,
    reporting_requirements TEXT,
    reporting_requirements_updated_at TEXT,
    reporting_requirements_updated_by TEXT,
    notes TEXT,
    notes_updated_at TEXT,
    notes_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    -- Change CASCADE to RESTRICT for project_id
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE RESTRICT,
    FOREIGN KEY (donor_id) REFERENCES donors(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (project_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (donor_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (grant_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (amount_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (currency_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (start_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (end_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (reporting_requirements_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (notes_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

INSERT INTO project_funding_new SELECT * FROM project_funding;
DROP TABLE project_funding;
ALTER TABLE project_funding_new RENAME TO project_funding;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_project_funding_project ON project_funding(project_id);
CREATE INDEX IF NOT EXISTS idx_project_funding_donor ON project_funding(donor_id);
CREATE INDEX IF NOT EXISTS idx_project_funding_status ON project_funding(status);
CREATE INDEX IF NOT EXISTS idx_project_funding_updated_at ON project_funding(updated_at);
CREATE INDEX IF NOT EXISTS idx_project_funding_deleted_at ON project_funding(deleted_at);
CREATE INDEX IF NOT EXISTS idx_project_funding_created_by ON project_funding(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_project_funding_updated_by ON project_funding(updated_by_user_id);

-- 4. For livelihoods table (change CASCADE to RESTRICT for project_id)
CREATE TABLE livelihoods_new (
    id TEXT PRIMARY KEY,
    participant_id TEXT NOT NULL,
    project_id TEXT NOT NULL,
    grant_amount REAL,
    grant_amount_updated_at TEXT,
    grant_amount_updated_by TEXT,
    purpose TEXT,
    purpose_updated_at TEXT,
    purpose_updated_by TEXT,
    progress1 TEXT,
    progress1_updated_at TEXT,
    progress1_updated_by TEXT,
    progress2 TEXT,
    progress2_updated_at TEXT,
    progress2_updated_by TEXT,
    outcome TEXT,
    outcome_updated_at TEXT,
    outcome_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,

    -- Keep CASCADE for participant_id but change project_id to RESTRICT
    FOREIGN KEY (participant_id) REFERENCES participants(id) ON DELETE CASCADE,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (grant_amount_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (purpose_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (progress1_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (progress2_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcome_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

INSERT INTO livelihoods_new SELECT * FROM livelihoods;
DROP TABLE livelihoods;
ALTER TABLE livelihoods_new RENAME TO livelihoods;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_livelihoods_participant ON livelihoods(participant_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_project ON livelihoods(project_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_updated_at ON livelihoods(updated_at);
CREATE INDEX IF NOT EXISTS idx_livelihoods_deleted_at ON livelihoods(deleted_at);
CREATE INDEX IF NOT EXISTS idx_livelihoods_created_by ON livelihoods(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_updated_by ON livelihoods(updated_by_user_id);

-- #############################################################
-- ##          Summarize the changes                          ##
-- #############################################################
-- The following foreign key constraint changes were made:
--
-- 1. Changed strategic_goal_id in projects table from ON DELETE CASCADE to ON DELETE RESTRICT
-- 2. Changed project_id in workshops table from ON DELETE CASCADE to ON DELETE RESTRICT
-- 3. Changed project_id in project_funding table from ON DELETE CASCADE to ON DELETE RESTRICT
-- 4. Changed project_id in livelihoods table from ON DELETE CASCADE to ON DELETE RESTRICT
--
-- The following foreign key constraints were kept as ON DELETE CASCADE:
-- - activities.project_id referencing projects.id
-- - workshop_participants.workshop_id referencing workshops.id
-- - workshop_participants.participant_id referencing participants.id
-- - livelihoods.participant_id referencing participants.id
-- - subsequent_grants.livelihood_id referencing livelihoods.id

-- Turn foreign keys back on
PRAGMA foreign_keys = ON;-- Tombstones and Hard Delete Migration
-- Created at: 2024-04-07

-- Enable foreign keys
PRAGMA foreign_keys = OFF;

-- Drop the locks table since we're removing that feature
DROP TABLE IF EXISTS locks;

-- Create the tombstones table for tracking hard-deleted entities
CREATE TABLE IF NOT EXISTS tombstones (
    id TEXT PRIMARY KEY, -- UUID for the tombstone itself
    entity_id TEXT NOT NULL, -- UUID of the deleted entity
    entity_type TEXT NOT NULL, -- Table name of the deleted entity
    deleted_by TEXT NOT NULL, -- User ID who performed the deletion
    deleted_at TEXT NOT NULL, -- Timestamp when deletion occurred
    operation_id TEXT NOT NULL, -- UUID for batch operations
    
    FOREIGN KEY (deleted_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Create indices for efficient tombstone lookups
CREATE INDEX IF NOT EXISTS idx_tombstones_entity ON tombstones(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_tombstones_deleted_by ON tombstones(deleted_by);
CREATE INDEX IF NOT EXISTS idx_tombstones_deleted_at ON tombstones(deleted_at);
CREATE INDEX IF NOT EXISTS idx_tombstones_operation ON tombstones(operation_id);

-- Update the change_log table to handle hard deletions
-- First, we need to remove the existing CHECK constraint

-- Create a new version of the change_log table with the updated constraint
CREATE TABLE IF NOT EXISTS change_log_new (
    operation_id TEXT PRIMARY KEY, -- Unique ID for this specific change event (UUID)
    entity_table TEXT NOT NULL,    -- e.g., 'users', 'projects'
    entity_id TEXT NOT NULL,       -- The ID of the record changed
    operation_type TEXT NOT NULL CHECK (operation_type IN (
        'create',       -- Record created
        'update',       -- Field updated
        'delete',       -- Record soft deleted (set deleted_at)
        'hard_delete'   -- Record permanently deleted
     )),
    field_name TEXT,               -- Field name for 'update'. NULL otherwise.
    old_value TEXT,                -- Optional: Previous value (JSON encoded) for auditing/debugging
    new_value TEXT,                -- New value (JSON encoded) for 'create', 'update'. NULL for delete.
    timestamp TEXT NOT NULL,       -- High precision ISO8601 UTC timestamp of the change
    user_id TEXT NOT NULL,         -- User performing the change
    device_id TEXT,                -- Optional: ID of the device making the change

    -- Sync processing state
    sync_batch_id TEXT,            -- ID of the sync batch this belongs to (upload or download)
    processed_at TEXT,             -- Timestamp when this incoming change was merged locally
    sync_error TEXT,               -- If processing failed

    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL, -- User might be deleted later
    FOREIGN KEY (sync_batch_id) REFERENCES sync_batches(batch_id) ON DELETE SET NULL -- Link to sync batch
);

-- Copy existing data
INSERT INTO change_log_new 
SELECT * FROM change_log;

-- Drop the old table
DROP TABLE change_log;

-- Rename the new table to change_log
ALTER TABLE change_log_new RENAME TO change_log;

-- Recreate indices
CREATE INDEX IF NOT EXISTS idx_change_log_entity ON change_log(entity_table, entity_id);
CREATE INDEX IF NOT EXISTS idx_change_log_timestamp_user ON change_log(timestamp, user_id);
CREATE INDEX IF NOT EXISTS idx_change_log_operation ON change_log(operation_type);
CREATE INDEX IF NOT EXISTS idx_change_log_batch ON change_log(sync_batch_id);
CREATE INDEX IF NOT EXISTS idx_change_log_unprocessed_for_upload 
ON change_log(entity_table, entity_id, timestamp) 
WHERE sync_batch_id IS NULL AND processed_at IS NULL;

-- Add a new index for hard_delete operations specifically
CREATE INDEX IF NOT EXISTS idx_change_log_hard_delete
ON change_log(entity_table, entity_id) 
WHERE operation_type = 'hard_delete';

-- Update the audit_logs table to ensure it also supports hard_delete operations
CREATE TABLE IF NOT EXISTS audit_logs_new (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    action TEXT NOT NULL CHECK (action IN (
        'create', 'update', 'delete', 'hard_delete', -- Corresponds to change_log operations
        'login_success', 'login_fail', 'logout', -- Auth events
        'sync_upload_start', 'sync_upload_complete', 'sync_upload_fail', -- Sync events
        'sync_download_start', 'sync_download_complete', 'sync_download_fail',
        'merge_conflict_resolved', 'merge_conflict_detected', -- Sync details
        'permission_denied', 'data_export', 'data_import' -- Other actions
        )),
    entity_table TEXT, -- Table related to action (users, projects...)
    entity_id TEXT,    -- Record ID related to action
    field_name TEXT,   -- Field related to action (if applicable)
    details TEXT,      -- JSON blob for extra context (e.g., error msg, IP address, change diff summary)
    timestamp TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Copy existing data
INSERT INTO audit_logs_new
SELECT * FROM audit_logs;

-- Drop the old table
DROP TABLE audit_logs;

-- Rename the new table to audit_logs
ALTER TABLE audit_logs_new RENAME TO audit_logs;

-- Recreate indices
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target ON audit_logs(entity_table, entity_id);

-- Enable foreign keys again
PRAGMA foreign_keys = ON;

-- Done! -- Device Sync Migration
-- Created at: 2024-04-12
-- Description: Adds device sync state tracking

-- Enable foreign keys
PRAGMA foreign_keys = OFF;

-- Create device sync state table
CREATE TABLE IF NOT EXISTS device_sync_state (
    device_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    last_upload_timestamp TEXT,
    last_download_timestamp TEXT,
    last_sync_status TEXT CHECK(last_sync_status IN ('success', 'partial_success', 'failed', 'in_progress')),
    last_sync_attempt_at TEXT,  -- When a sync was last attempted regardless of outcome
    server_version INTEGER DEFAULT 0,  -- To track server-side version vector
    sync_enabled INTEGER DEFAULT 1,    -- Allow disabling sync on specific devices
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Add indices for efficiency
CREATE INDEX IF NOT EXISTS idx_device_sync_state_user_id ON device_sync_state(user_id);
CREATE INDEX IF NOT EXISTS idx_device_sync_state_updated_at ON device_sync_state(updated_at);


CREATE TABLE IF NOT EXISTS app_connection_settings (
    id TEXT PRIMARY KEY CHECK(id = 'cloud'),
    api_endpoint TEXT NOT NULL,  -- Base URL for your cloud API
    api_version TEXT,            -- API version for compatibility
    connection_timeout INTEGER DEFAULT 30000,  -- Timeout in milliseconds
    offline_mode_enabled INTEGER DEFAULT 0,
    retry_count INTEGER DEFAULT 3,             -- Number of retries on failure
    retry_delay INTEGER DEFAULT 5000,          -- Delay between retries
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
);


-- Add device tracking to sync_batches table
-- Since SQLite doesn't support adding NOT NULL columns with a default value,
-- we need to recreate the table
CREATE TABLE sync_batches_new (
    batch_id TEXT PRIMARY KEY,
    device_id TEXT NOT NULL, -- New column for device tracking
    direction TEXT NOT NULL CHECK (direction IN ('upload', 'download')),
    status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'completed', 'failed', 'partially_failed')),
    item_count INTEGER DEFAULT 0,
    total_size INTEGER DEFAULT 0,
    priority INTEGER DEFAULT 5,
    attempts INTEGER DEFAULT 0,
    last_attempt_at TEXT,
    error_message TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    completed_at TEXT
);

-- Copy existing data (adding a default device_id for existing records)
INSERT INTO sync_batches_new (
    batch_id, device_id, direction, status, item_count, 
    total_size, priority, attempts, last_attempt_at,
    error_message, created_at, completed_at
)
SELECT 
    batch_id, 'legacy_device', direction, status, item_count,
    total_size, priority, attempts, last_attempt_at,
    error_message, created_at, completed_at
FROM sync_batches;

-- Drop old table
DROP TABLE sync_batches;

-- Rename new table to original name
ALTER TABLE sync_batches_new RENAME TO sync_batches;

-- Recreate indices
CREATE INDEX IF NOT EXISTS idx_sync_batches_status_priority ON sync_batches(status, priority, created_at);
CREATE INDEX IF NOT EXISTS idx_sync_batches_direction ON sync_batches(direction, status);
-- Add new device-specific index
CREATE INDEX IF NOT EXISTS idx_sync_batches_device ON sync_batches(device_id, status);

-- Add device metadata table for tracking known devices
CREATE TABLE IF NOT EXISTS device_metadata (
    device_id TEXT PRIMARY KEY,
    name TEXT NOT NULL,           -- User-friendly device name
    platform TEXT NOT NULL,       -- iOS, iPadOS, macOS, etc.
    model TEXT,                   -- Device model information
    os_version TEXT,              -- OS version information
    app_version TEXT NOT NULL,    -- App version when last used
    last_active_at TEXT,          -- When the device was last active
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
);

-- Add index for last active devices
CREATE INDEX IF NOT EXISTS idx_device_metadata_last_active ON device_metadata(last_active_at DESC);

-- Add a field to track which device created a change_log entry (if not already populated)
-- SQLite doesn't support checking if a column exists, so we'll rely on the migration tool
-- to handle this properly

-- Enable foreign keys again
PRAGMA foreign_keys = ON;-- Migration to make certain foreign key relationships optional (nullable)
-- Goal: Allow records in these tables to exist without being linked to their parent.
-- IMPORTANT: Ensure corresponding Rust types are updated to Option<Uuid>.

PRAGMA foreign_keys=off; -- Disable FK constraints during table modifications


-- 1. Modify 'projects' table: make 'strategic_goal_id' NULLable
CREATE TABLE projects_new (
    id TEXT PRIMARY KEY,
    strategic_goal_id TEXT NULL, -- Made NULLable
    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,
    objective TEXT,
    objective_updated_at TEXT,
    objective_updated_by TEXT,
    outcome TEXT,
    outcome_updated_at TEXT,
    outcome_updated_by TEXT,
    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,
    timeline TEXT,
    timeline_updated_at TEXT,
    timeline_updated_by TEXT,
    responsible_team TEXT,
    responsible_team_updated_at TEXT,
    responsible_team_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (strategic_goal_id) REFERENCES strategic_goals(id) ON DELETE RESTRICT, -- Keep RESTRICT
    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (objective_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (outcome_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (timeline_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (responsible_team_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
INSERT INTO projects_new (id, strategic_goal_id, name, name_updated_at, name_updated_by, objective, objective_updated_at, objective_updated_by, outcome, outcome_updated_at, outcome_updated_by, status_id, status_id_updated_at, status_id_updated_by, timeline, timeline_updated_at, timeline_updated_by, responsible_team, responsible_team_updated_at, responsible_team_updated_by, created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id)
SELECT id, strategic_goal_id, name, name_updated_at, name_updated_by, objective, objective_updated_at, objective_updated_by, outcome, outcome_updated_at, outcome_updated_by, status_id, status_id_updated_at, status_id_updated_by, timeline, timeline_updated_at, timeline_updated_by, responsible_team, responsible_team_updated_at, responsible_team_updated_by, created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id FROM projects;
DROP TABLE projects;
ALTER TABLE projects_new RENAME TO projects;

-- Recreate indexes for 'projects'
CREATE INDEX IF NOT EXISTS idx_projects_strategic_goal ON projects(strategic_goal_id);
CREATE INDEX IF NOT EXISTS idx_projects_status ON projects(status_id);
CREATE INDEX IF NOT EXISTS idx_projects_updated_at ON projects(updated_at);
CREATE INDEX IF NOT EXISTS idx_projects_deleted_at ON projects(deleted_at);
CREATE INDEX IF NOT EXISTS idx_projects_created_by ON projects(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_projects_updated_by ON projects(updated_by_user_id);
CREATE INDEX IF NOT EXISTS idx_projects_name ON projects(name);

-- 2. Modify 'activities' table: make 'project_id' NULLable
-- Assuming the dependency is activities -> projects based on schema
CREATE TABLE activities_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NULL, -- Made NULLable
    description TEXT,
    description_updated_at TEXT,
    description_updated_by TEXT,
    kpi TEXT,
    kpi_updated_at TEXT,
    kpi_updated_by TEXT,
    target_value REAL,
    target_value_updated_at TEXT,
    target_value_updated_by TEXT,
    actual_value REAL DEFAULT 0,
    actual_value_updated_at TEXT,
    actual_value_updated_by TEXT,
    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE, -- Keep CASCADE
    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (description_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (kpi_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (target_value_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (actual_value_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
INSERT INTO activities_new (id, project_id, description, description_updated_at, description_updated_by, kpi, kpi_updated_at, kpi_updated_by, target_value, target_value_updated_at, target_value_updated_by, actual_value, actual_value_updated_at, actual_value_updated_by, status_id, status_id_updated_at, status_id_updated_by, created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id)
SELECT id, project_id, description, description_updated_at, description_updated_by, kpi, kpi_updated_at, kpi_updated_by, target_value, target_value_updated_at, target_value_updated_by, actual_value, actual_value_updated_at, actual_value_updated_by, status_id, status_id_updated_at, status_id_updated_by, created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id FROM activities;
DROP TABLE activities;
ALTER TABLE activities_new RENAME TO activities;

-- Recreate indexes for 'activities'
CREATE INDEX IF NOT EXISTS idx_activities_project ON activities(project_id);
CREATE INDEX IF NOT EXISTS idx_activities_status ON activities(status_id);
CREATE INDEX IF NOT EXISTS idx_activities_updated_at ON activities(updated_at);
CREATE INDEX IF NOT EXISTS idx_activities_deleted_at ON activities(deleted_at);
CREATE INDEX IF NOT EXISTS idx_activities_created_by ON activities(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_activities_updated_by ON activities(updated_by_user_id);


-- 3. Modify 'workshops' table: make 'project_id' NULLable
CREATE TABLE workshops_new (
    id TEXT PRIMARY KEY,
    project_id TEXT NULL, -- Made NULLable
    title TEXT NOT NULL,
    title_updated_at TEXT,
    title_updated_by TEXT,
    objective TEXT,
    objective_updated_at TEXT,
    objective_updated_by TEXT,
    rationale TEXT,
    rationale_updated_at TEXT,
    rationale_updated_by TEXT,
    methodology TEXT,
    methodology_updated_at TEXT,
    methodology_updated_by TEXT,
    facilitator TEXT,
    facilitator_updated_at TEXT,
    facilitator_updated_by TEXT,
    event_date TEXT,
    event_date_updated_at TEXT,
    event_date_updated_by TEXT,
    start_time TEXT,
    start_time_updated_at TEXT,
    start_time_updated_by TEXT,
    end_time TEXT,
    end_time_updated_at TEXT,
    end_time_updated_by TEXT,
    location TEXT,
    location_updated_at TEXT,
    location_updated_by TEXT,
    total_male_participants INTEGER DEFAULT 0,
    total_male_participants_updated_at TEXT,
    total_male_participants_updated_by TEXT,
    total_female_participants INTEGER DEFAULT 0,
    total_female_participants_updated_at TEXT,
    total_female_participants_updated_by TEXT,
    total_other_participants INTEGER DEFAULT 0,
    total_other_participants_updated_at TEXT,
    total_other_participants_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (title_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (objective_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (rationale_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (methodology_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (facilitator_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (event_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (start_time_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (end_time_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (location_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (total_male_participants_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (total_female_participants_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (total_other_participants_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Fully corrected INSERT statement for workshops, selecting only columns that existed in basic.sql
-- and providing defaults/NULLs for columns added/changed in workshops_new.
INSERT INTO workshops_new (
    -- Columns present in workshops_new
    id, project_id, title, title_updated_at, title_updated_by, 
    objective, objective_updated_at, objective_updated_by, 
    rationale, rationale_updated_at, rationale_updated_by, 
    methodology, methodology_updated_at, methodology_updated_by, 
    facilitator, facilitator_updated_at, facilitator_updated_by, 
    event_date, event_date_updated_at, event_date_updated_by, 
    start_time, start_time_updated_at, start_time_updated_by, 
    end_time, end_time_updated_at, end_time_updated_by, 
    location, location_updated_at, location_updated_by, 
    total_male_participants, total_male_participants_updated_at, total_male_participants_updated_by, 
    total_female_participants, total_female_participants_updated_at, total_female_participants_updated_by, 
    total_other_participants, total_other_participants_updated_at, total_other_participants_updated_by, 
    created_at, updated_at, created_by_user_id, updated_by_user_id, 
    deleted_at, deleted_by_user_id
)
SELECT 
    -- Map from columns that ACTUALLY EXISTED in the old workshops table (from basic.sql)
    id, 
    project_id, 
    '' as title, -- New column, default to empty string (NOT NULL)
    NULL as title_updated_at, -- New column
    NULL as title_updated_by, -- New column
    NULL as objective, -- New column
    NULL as objective_updated_at, -- New column
    NULL as objective_updated_by, -- New column
    NULL as rationale, -- New column
    NULL as rationale_updated_at, -- New column
    NULL as rationale_updated_by, -- New column
    NULL as methodology, -- New column
    NULL as methodology_updated_at, -- New column
    NULL as methodology_updated_by, -- New column
    NULL as facilitator, -- New column
    NULL as facilitator_updated_at, -- New column
    NULL as facilitator_updated_by, -- New column
    event_date, -- Existed 
    event_date_updated_at, -- Existed
    event_date_updated_by, -- Existed
    NULL as start_time, -- New column
    NULL as start_time_updated_at, -- New column
    NULL as start_time_updated_by, -- New column
    NULL as end_time, -- New column
    NULL as end_time_updated_at, -- New column
    NULL as end_time_updated_by, -- New column
    location, -- Existed
    location_updated_at, -- Existed
    location_updated_by, -- Existed
    0 as total_male_participants, -- New column, default to 0
    NULL as total_male_participants_updated_at, -- New column
    NULL as total_male_participants_updated_by, -- New column
    0 as total_female_participants, -- New column, default to 0
    NULL as total_female_participants_updated_at, -- New column
    NULL as total_female_participants_updated_by, -- New column
    0 as total_other_participants, -- New column, default to 0
    NULL as total_other_participants_updated_at, -- New column
    NULL as total_other_participants_updated_by, -- New column
    created_at, -- Existed
    updated_at, -- Existed
    created_by_user_id, -- Existed
    updated_by_user_id, -- Existed
    deleted_at, -- Existed
    deleted_by_user_id -- Existed
    -- NOTE: We are IGNORING columns from the old table that are NOT in the new one:
    -- purpose, purpose_updated_at, purpose_updated_by
    -- budget, budget_updated_at, budget_updated_by
    -- actuals, actuals_updated_at, actuals_updated_by
    -- participant_count, participant_count_updated_at, participant_count_updated_by
    -- local_partner, local_partner_updated_at, local_partner_updated_by
    -- partner_responsibility, partner_responsibility_updated_at, partner_responsibility_updated_by
    -- partnership_success, partnership_success_updated_at, partnership_success_updated_by
    -- capacity_challenges, capacity_challenges_updated_at, capacity_challenges_updated_by
    -- strengths, strengths_updated_at, strengths_updated_by
    -- outcomes, outcomes_updated_at, outcomes_updated_by
    -- recommendations, recommendations_updated_at, recommendations_updated_by
    -- challenge_resolution, challenge_resolution_updated_at, challenge_resolution_updated_by
FROM workshops; 
DROP TABLE workshops;
ALTER TABLE workshops_new RENAME TO workshops;

-- Recreate indexes for 'workshops'
CREATE INDEX IF NOT EXISTS idx_workshops_project ON workshops(project_id);
CREATE INDEX IF NOT EXISTS idx_workshops_event_date ON workshops(event_date);
CREATE INDEX IF NOT EXISTS idx_workshops_location ON workshops(location);
CREATE INDEX IF NOT EXISTS idx_workshops_updated_at ON workshops(updated_at);
CREATE INDEX IF NOT EXISTS idx_workshops_deleted_at ON workshops(deleted_at);
CREATE INDEX IF NOT EXISTS idx_workshops_created_by ON workshops(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_workshops_updated_by ON workshops(updated_by_user_id);


-- 4. Modify 'workshop_participants' table: make 'workshop_id' and 'participant_id' NULLable
CREATE TABLE workshop_participants_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    workshop_id TEXT NULL, -- Made NULLable
    participant_id TEXT NULL, -- Made NULLable
    notes TEXT,
    notes_updated_at TEXT,
    notes_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (workshop_id) REFERENCES workshops(id) ON DELETE RESTRICT, -- Keep RESTRICT
    FOREIGN KEY (participant_id) REFERENCES participants(id) ON DELETE RESTRICT, -- Keep RESTRICT
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (notes_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
INSERT INTO workshop_participants_new (
    -- Columns from workshop_participants_new definition
    id, workshop_id, participant_id, notes, notes_updated_at, notes_updated_by, 
    created_at, updated_at, created_by_user_id, updated_by_user_id, 
    deleted_at, deleted_by_user_id
)
SELECT 
    -- Map from columns that ACTUALLY EXISTED in the old workshop_participants table (from basic.sql)
    id,                 -- Existed as PK
    workshop_id,        -- Existed
    participant_id,     -- Existed
    NULL as notes,      -- New column in _new table
    NULL as notes_updated_at, -- New column in _new table
    NULL as notes_updated_by, -- New column in _new table
    created_at,         -- Existed
    updated_at,         -- Existed
    created_by_user_id, -- Existed
    updated_by_user_id, -- Existed
    deleted_at,         -- Existed
    deleted_by_user_id  -- Existed
    -- NOTE: We are IGNORING columns from the old table that are NOT in the new one:
    -- pre_evaluation, pre_evaluation_updated_at, pre_evaluation_updated_by
    -- post_evaluation, post_evaluation_updated_at, post_evaluation_updated_by
FROM workshop_participants; 
DROP TABLE workshop_participants;
ALTER TABLE workshop_participants_new RENAME TO workshop_participants;

-- Recreate indexes for 'workshop_participants'
CREATE INDEX IF NOT EXISTS idx_workshop_participants_workshop ON workshop_participants(workshop_id);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_participant ON workshop_participants(participant_id);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_updated_at ON workshop_participants(updated_at);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_deleted_at ON workshop_participants(deleted_at);


-- 5. Modify 'livelihoods' table: make 'participant_id' and 'project_id' NULLable
CREATE TABLE livelihoods_new (
    id TEXT PRIMARY KEY,
    participant_id TEXT NULL, -- Made NULLable
    project_id TEXT NULL, -- Made NULLable
    type TEXT NOT NULL,
    type_updated_at TEXT,
    type_updated_by TEXT,
    description TEXT,
    description_updated_at TEXT,
    description_updated_by TEXT,
    status_id INTEGER,
    status_id_updated_at TEXT,
    status_id_updated_by TEXT,
    initial_grant_date TEXT,
    initial_grant_date_updated_at TEXT,
    initial_grant_date_updated_by TEXT,
    initial_grant_amount REAL,
    initial_grant_amount_updated_at TEXT,
    initial_grant_amount_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (participant_id) REFERENCES participants(id) ON DELETE RESTRICT, -- Keep RESTRICT
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE RESTRICT, -- Keep RESTRICT
    FOREIGN KEY (status_id) REFERENCES status_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (type_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (description_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (status_id_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (initial_grant_date_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (initial_grant_amount_updated_by) REFERENCES users(id) ON DELETE SET NULL
);
INSERT INTO livelihoods_new (
    -- Columns from livelihoods_new definition
    id, participant_id, project_id, 
    type, type_updated_at, type_updated_by, 
    description, description_updated_at, description_updated_by, 
    status_id, status_id_updated_at, status_id_updated_by, 
    initial_grant_date, initial_grant_date_updated_at, initial_grant_date_updated_by, 
    initial_grant_amount, initial_grant_amount_updated_at, initial_grant_amount_updated_by, 
    created_at, updated_at, created_by_user_id, updated_by_user_id, 
    deleted_at, deleted_by_user_id
)
SELECT 
    -- Map from columns that ACTUALLY EXISTED in the old livelihoods table (from basic.sql)
    id, 
    participant_id, 
    project_id, 
    'Unknown' as type, -- New column (NOT NULL in new schema?), provide default
    NULL as type_updated_at, -- New column
    NULL as type_updated_by, -- New column
    NULL as description, -- New column
    NULL as description_updated_at, -- New column
    NULL as description_updated_by, -- New column
    NULL as status_id, -- New column
    NULL as status_id_updated_at, -- New column
    NULL as status_id_updated_by, -- New column
    NULL as initial_grant_date, -- New column
    NULL as initial_grant_date_updated_at, -- New column
    NULL as initial_grant_date_updated_by, -- New column
    NULL as initial_grant_amount, -- New column
    NULL as initial_grant_amount_updated_at, -- New column
    NULL as initial_grant_amount_updated_by, -- New column
    created_at, 
    updated_at, 
    created_by_user_id, 
    updated_by_user_id, 
    deleted_at, 
    deleted_by_user_id
    -- NOTE: We are IGNORING columns from the old table that are NOT in the new one:
    -- grant_amount, grant_amount_updated_at, grant_amount_updated_by
    -- purpose, purpose_updated_at, purpose_updated_by
    -- progress1, progress1_updated_at, progress1_updated_by
    -- progress2, progress2_updated_at, progress2_updated_by
    -- outcome, outcome_updated_at, outcome_updated_by
FROM livelihoods; 
DROP TABLE livelihoods;
ALTER TABLE livelihoods_new RENAME TO livelihoods;

-- Recreate indexes for 'livelihoods'
CREATE INDEX IF NOT EXISTS idx_livelihoods_participant ON livelihoods(participant_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_project ON livelihoods(project_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_updated_at ON livelihoods(updated_at);
CREATE INDEX IF NOT EXISTS idx_livelihoods_deleted_at ON livelihoods(deleted_at);
CREATE INDEX IF NOT EXISTS idx_livelihoods_created_by ON livelihoods(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_livelihoods_updated_by ON livelihoods(updated_by_user_id);


PRAGMA foreign_keys=on; -- Re-enable FK constraints-- Migration to add back evaluation columns to workshop_participants
-- Created at: 2024-04-20
-- Description: Adds pre_evaluation and post_evaluation columns back to workshop_participants table

PRAGMA foreign_keys=off;

-- Modify workshop_participants table to add evaluation columns
CREATE TABLE workshop_participants_new (
    id TEXT PRIMARY KEY,
    workshop_id TEXT NOT NULL,
    participant_id TEXT NULL,
    notes TEXT,
    notes_updated_at TEXT,
    notes_updated_by TEXT,
    pre_evaluation TEXT,
    pre_evaluation_updated_at TEXT,
    pre_evaluation_updated_by TEXT,
    post_evaluation TEXT,
    post_evaluation_updated_at TEXT,
    post_evaluation_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (workshop_id) REFERENCES workshops(id) ON DELETE CASCADE,
    FOREIGN KEY (participant_id) REFERENCES participants(id) ON DELETE SET NULL,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (notes_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (pre_evaluation_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (post_evaluation_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    UNIQUE(workshop_id, participant_id) ON CONFLICT REPLACE
);

-- Copy existing data, preserving existing columns
INSERT INTO workshop_participants_new 
SELECT 
    id,
    workshop_id,
    participant_id,
    notes,
    notes_updated_at,
    notes_updated_by,
    NULL as pre_evaluation,
    NULL as pre_evaluation_updated_at,
    NULL as pre_evaluation_updated_by,
    NULL as post_evaluation,
    NULL as post_evaluation_updated_at,
    NULL as post_evaluation_updated_by,
    created_at,
    updated_at,
    created_by_user_id,
    updated_by_user_id,
    deleted_at,
    deleted_by_user_id
FROM workshop_participants;

DROP TABLE workshop_participants;
ALTER TABLE workshop_participants_new RENAME TO workshop_participants;

-- Recreate indexes
CREATE INDEX IF NOT EXISTS idx_workshop_participants_workshop ON workshop_participants(workshop_id);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_participant ON workshop_participants(participant_id);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_updated_at ON workshop_participants(updated_at);
CREATE INDEX IF NOT EXISTS idx_workshop_participants_deleted_at ON workshop_participants(deleted_at);

PRAGMA foreign_keys=on; -- Migration for Document Handling Updates
-- Created at: 2024-04-21
-- Description: Adds sync priority to change log, and compressed path/linked field to media documents.

PRAGMA foreign_keys=off; -- Recommended for schema changes

-- Add sync priority to the change_log table
ALTER TABLE change_log ADD COLUMN priority INTEGER DEFAULT 5; -- Add priority, default to normal (e.g., 5)

-- Add compressed file path and linked field name to media_documents table
-- ALTER TABLE media_documents ADD COLUMN compressed_file_path TEXT NULL; -- Commented out: Column now created in basic.sql
ALTER TABLE media_documents ADD COLUMN linked_field_name TEXT NULL;

-- No need to recreate indexes specifically for these added nullable columns usually
-- SQLite handles indexes on NULL values appropriately.

PRAGMA foreign_keys=on; -- Add sync_priority column to media_documents
ALTER TABLE media_documents ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- Add sync_priority column to strategic_goals
ALTER TABLE strategic_goals ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- Add sync_priority column to projects
ALTER TABLE projects ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- Add sync_priority column to workshops
ALTER TABLE workshops ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- Add sync_priority column to participants
ALTER TABLE participants ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- Add sync_priority column to livelihoods
ALTER TABLE livelihoods ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- Add sync_priority column to subsequent_grants
ALTER TABLE subsequent_grants ADD COLUMN sync_priority INTEGER NOT NULL DEFAULT 1; -- Default to Normal

-- NOTE: Add to other relevant tables if necessary (e.g., activities, donors) -- SQLite does not directly support ALTER COLUMN to remove NOT NULL.
-- We need to recreate the table.

-- 1. Rename the existing table
ALTER TABLE media_documents RENAME TO media_documents_old;

-- 2. Create the new table with related_id as nullable and add temp_related_id
CREATE TABLE media_documents (
    id TEXT PRIMARY KEY NOT NULL,
    related_table TEXT NOT NULL,
    related_id TEXT NULL, -- Made nullable
    type_id TEXT NOT NULL,
    file_path TEXT NOT NULL,
    original_filename TEXT NOT NULL,
    title TEXT NULL,
    mime_type TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    field_identifier TEXT NULL,
    compression_status TEXT NOT NULL DEFAULT 'pending',
    compressed_file_path TEXT NULL,
    blob_sync_status TEXT NOT NULL DEFAULT 'pending',
    sync_priority INTEGER NOT NULL DEFAULT 1,
    temp_related_id TEXT NULL, -- New column
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    created_by_user_id TEXT NULL,
    updated_by_user_id TEXT NULL,
    deleted_at TEXT NULL,
    deleted_by_user_id TEXT NULL,
    FOREIGN KEY (type_id) REFERENCES document_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL
);

-- Add index for temp_related_id for faster lookups
CREATE INDEX idx_media_documents_temp_related_id ON media_documents(temp_related_id) WHERE temp_related_id IS NOT NULL;
-- Add index for related_id
CREATE INDEX idx_media_documents_related_id ON media_documents(related_id) WHERE related_id IS NOT NULL;


-- 3. Copy data from the old table to the new table
INSERT INTO media_documents (
    id, related_table, related_id, type_id, file_path, original_filename,
    title, mime_type, size_bytes, field_identifier,
    compression_status, compressed_file_path, blob_sync_status,
    sync_priority, temp_related_id, -- temp_related_id will be NULL initially
    created_at, updated_at, created_by_user_id, updated_by_user_id,
    deleted_at, deleted_by_user_id
)
SELECT
    id, related_table, related_id, type_id, file_path, original_filename,
    title, mime_type, size_bytes, field_identifier,
    compression_status, compressed_file_path, blob_sync_status,
    sync_priority, NULL, -- Set temp_related_id to NULL
    created_at, updated_at, created_by_user_id, updated_by_user_id,
    deleted_at, deleted_by_user_id
FROM media_documents_old;

-- 4. Drop the old table
DROP TABLE media_documents_old; -- Add migration script here
    -- Add total_files_skipped column to compression_stats table
    ALTER TABLE compression_stats
    ADD COLUMN total_files_skipped INTEGER NOT NULL DEFAULT 0;-- Add migration script here

-- SQLite does not support ALTER TABLE ADD CONSTRAINT CHECK directly.
-- We must recreate the table with the new constraint.

-- Step 1: Disable foreign keys (Necessary because we drop/recreate the table)
PRAGMA foreign_keys=off;

-- Step 2: Start transaction -- REMOVED (sqlx-cli handles the transaction)
-- BEGIN TRANSACTION; -- REMOVED

-- Step 3: Create the new table with the desired schema including the CHECK constraint
CREATE TABLE document_types_new (
    id TEXT PRIMARY KEY, -- User-defined key
    name TEXT NOT NULL,
    name_updated_at TEXT,
    name_updated_by TEXT,
    allowed_extensions TEXT NOT NULL,
    allowed_extensions_updated_at TEXT,
    allowed_extensions_updated_by TEXT,
    max_size INTEGER NOT NULL,
    max_size_updated_at TEXT,
    max_size_updated_by TEXT,
    compression_level INTEGER NOT NULL DEFAULT 6,
    compression_level_updated_at TEXT,
    compression_level_updated_by TEXT,
    -- Apply the new CHECK constraint
    compression_method TEXT DEFAULT 'lossless' 
        CHECK(compression_method IN ('lossless', 'lossy', 'pdf_optimize', 'office_optimize', 'none')),
    compression_method_updated_at TEXT,
    compression_method_updated_by TEXT,
    min_size_for_compression INTEGER DEFAULT 10240,
    min_size_for_compression_updated_at TEXT,
    min_size_for_compression_updated_by TEXT,
    description TEXT,
    description_updated_at TEXT,
    description_updated_by TEXT,
    default_priority TEXT NOT NULL DEFAULT 'normal' CHECK(default_priority IN ('high', 'normal', 'low', 'never')),
    default_priority_updated_at TEXT,
    default_priority_updated_by TEXT,
    icon TEXT,
    icon_updated_at TEXT,
    icon_updated_by TEXT,
    related_tables TEXT,
    related_tables_updated_at TEXT,
    related_tables_updated_by TEXT,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    created_by_user_id TEXT,
    updated_by_user_id TEXT,
    deleted_at TEXT DEFAULT NULL,
    deleted_by_user_id TEXT DEFAULT NULL,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (name_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (allowed_extensions_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (max_size_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (compression_level_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (compression_method_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (min_size_for_compression_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (description_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (default_priority_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (icon_updated_by) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (related_tables_updated_by) REFERENCES users(id) ON DELETE SET NULL
);

-- Step 4: Copy data from the old table to the new table
-- Ensure all columns from the original table are included here
INSERT INTO document_types_new (
    id, name, name_updated_at, name_updated_by, 
    allowed_extensions, allowed_extensions_updated_at, allowed_extensions_updated_by,
    max_size, max_size_updated_at, max_size_updated_by,
    compression_level, compression_level_updated_at, compression_level_updated_by,
    compression_method, compression_method_updated_at, compression_method_updated_by,
    min_size_for_compression, min_size_for_compression_updated_at, min_size_for_compression_updated_by,
    description, description_updated_at, description_updated_by,
    default_priority, default_priority_updated_at, default_priority_updated_by,
    icon, icon_updated_at, icon_updated_by,
    related_tables, related_tables_updated_at, related_tables_updated_by,
    created_at, updated_at, created_by_user_id, updated_by_user_id,
    deleted_at, deleted_by_user_id
)
SELECT 
    id, name, name_updated_at, name_updated_by, 
    allowed_extensions, allowed_extensions_updated_at, allowed_extensions_updated_by,
    max_size, max_size_updated_at, max_size_updated_by,
    compression_level, compression_level_updated_at, compression_level_updated_by,
    compression_method, compression_method_updated_at, compression_method_updated_by,
    min_size_for_compression, min_size_for_compression_updated_at, min_size_for_compression_updated_by,
    description, description_updated_at, description_updated_by,
    default_priority, default_priority_updated_at, default_priority_updated_by,
    icon, icon_updated_at, icon_updated_by,
    related_tables, related_tables_updated_at, related_tables_updated_by,
    created_at, updated_at, created_by_user_id, updated_by_user_id,
    deleted_at, deleted_by_user_id
FROM document_types;

-- Step 5: Drop the old table
DROP TABLE document_types;

-- Step 6: Rename the new table to the original name
ALTER TABLE document_types_new RENAME TO document_types;

-- Step 7: Recreate indexes that were on the original table
CREATE UNIQUE INDEX IF NOT EXISTS idx_document_types_name ON document_types(name) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_document_types_updated_at ON document_types(updated_at);
CREATE INDEX IF NOT EXISTS idx_document_types_deleted_at ON document_types(deleted_at);
CREATE INDEX IF NOT EXISTS idx_document_types_created_by ON document_types(created_by_user_id);
CREATE INDEX IF NOT EXISTS idx_document_types_updated_by ON document_types(updated_by_user_id);

-- Step 8: Commit the transaction -- REMOVED (sqlx-cli handles the transaction)
-- COMMIT; -- REMOVED

-- Step 9: Re-enable foreign keys
PRAGMA foreign_keys=on;
-- Begin transaction for restructuring media_documents

-- Create the new media_documents table with the updated schema
CREATE TABLE media_documents_new (
    id TEXT PRIMARY KEY NOT NULL,
    related_table TEXT NOT NULL,
    related_id TEXT NULL,
    type_id TEXT NOT NULL,
    original_filename TEXT NOT NULL, -- RENAMED from file_name
    file_path TEXT NOT NULL,
    compressed_file_path TEXT NULL,
    compressed_size_bytes INTEGER NULL, -- ADDED
    field_identifier TEXT NULL, -- RENAMED from linked_field_name
    title TEXT NULL,
    description TEXT NULL,
    mime_type TEXT NOT NULL, -- Made NOT NULL
    size_bytes INTEGER NOT NULL, -- RENAMED from file_size, Made NOT NULL
    compression_status TEXT NOT NULL DEFAULT 'PENDING', -- Added default
    blob_storage_key TEXT NULL,
    blob_sync_status TEXT NOT NULL DEFAULT 'PENDING', -- Added default
    sync_priority INTEGER NOT NULL DEFAULT 1, -- Added default (matches SyncPriority::Normal)
    temp_related_id TEXT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    created_by_user_id TEXT NULL,
    updated_by_user_id TEXT NULL,
    deleted_at TEXT NULL,
    deleted_by_user_id TEXT NULL,
    FOREIGN KEY (type_id) REFERENCES document_types(id) ON DELETE CASCADE
);

-- Copy data from the old table to the new table, handling renamed columns and NULLs
INSERT INTO media_documents_new (
    id, related_table, related_id, type_id, original_filename, file_path,
    compressed_file_path, compressed_size_bytes, field_identifier, title, description,
    mime_type, size_bytes, compression_status, blob_storage_key, blob_sync_status,
    sync_priority, temp_related_id, created_at, updated_at, created_by_user_id,
    updated_by_user_id, deleted_at, deleted_by_user_id
)
SELECT
    id, related_table, related_id, type_id, original_filename, file_path, -- FIXED: Use original_filename
    compressed_file_path, NULL, field_identifier, title, NULL, -- FIXED: Use field_identifier, Select NULL for description
    COALESCE(mime_type, 'application/octet-stream'), -- Handle potential NULL mime_type
    COALESCE(size_bytes, 0), -- FIXED: Use size_bytes
    compression_status, NULL, blob_sync_status, -- FIXED: Select NULL for blob_storage_key
    sync_priority, temp_related_id, created_at, updated_at, created_by_user_id,
    updated_by_user_id, deleted_at, deleted_by_user_id
FROM media_documents; -- Select from the original table

-- Drop the old table
DROP TABLE media_documents;

-- Rename the new table to the original name
ALTER TABLE media_documents_new RENAME TO media_documents;

-- Recreate indices that existed on the old table
CREATE INDEX idx_media_documents_related ON media_documents (related_table, related_id);
CREATE INDEX idx_media_documents_type ON media_documents (type_id);
CREATE INDEX idx_media_documents_temp_related_id ON media_documents (temp_related_id); 


=========================new migration===================================================

-- Document Handling System Enhancement Migration
-- Created: April 24, 2025
-- Description: Enhances document tracking, deletion, and error handling capabilities
-- Compatible with SQLite limitations

-- Disable foreign keys during migration
PRAGMA foreign_keys=off;

-- ========================================================================
-- 1. Enhance the tombstones table with additional metadata
-- ========================================================================

-- Add additional_metadata column to tombstones
ALTER TABLE tombstones ADD COLUMN additional_metadata TEXT NULL;

-- ========================================================================
-- 2. Enhance media_documents table with error handling fields
-- ========================================================================

-- First check what columns exist in the current table
PRAGMA table_info(media_documents);

-- Create a new media_documents table with enhanced error fields and cleanup
CREATE TABLE media_documents_new (
    id TEXT PRIMARY KEY NOT NULL,
    related_table TEXT NOT NULL,
    related_id TEXT NULL,           -- Nullable to support temporary documents
    temp_related_id TEXT NULL,      -- For documents uploaded before entity creation
    type_id TEXT NOT NULL,
    original_filename TEXT NOT NULL,
    file_path TEXT NOT NULL,
    compressed_file_path TEXT NULL,
    compressed_size_bytes INTEGER NULL,
    field_identifier TEXT NULL,     -- For linking to specific form fields
    title TEXT NULL,
    description TEXT NULL,
    mime_type TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    
    -- Error handling fields
    has_error INTEGER NOT NULL DEFAULT 0,       -- Boolean flag for error state
    error_message TEXT NULL,                    -- Error details
    error_type TEXT NULL CHECK(error_type IS NULL OR error_type IN (
        'storage_failure',          -- File system errors
        'conversion_failure',       -- Format conversion errors
        'compression_failure',      -- Compression errors
        'sync_failure',             -- Sync-related errors
        'permission_failure',       -- Access permission issues
        'upload_failure',           -- Initial upload failures
        'other'                     -- Miscellaneous errors
    )),
    
    -- Status fields
    compression_status TEXT NOT NULL DEFAULT 'pending',
    blob_status TEXT NOT NULL DEFAULT 'pending',
    blob_key TEXT NULL,
    sync_priority TEXT NOT NULL DEFAULT 'normal' CHECK(sync_priority IN ('high', 'normal', 'low', 'never')),
    
    -- Sync tracking
    last_sync_attempt_at TEXT NULL,
    sync_attempt_count INTEGER NOT NULL DEFAULT 0,
    
    -- Standard tracking fields
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    created_by_user_id TEXT NULL,
    updated_by_user_id TEXT NULL,
    deleted_at TEXT NULL,
    deleted_by_user_id TEXT NULL,
    
    FOREIGN KEY (type_id) REFERENCES document_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL
);

-- Copy existing data to the new table, handling missing columns
INSERT INTO media_documents_new (
    id, related_table, related_id, temp_related_id, type_id, original_filename,
    file_path, compressed_file_path, compressed_size_bytes, field_identifier, 
    title, description, mime_type, size_bytes, 
    -- Error fields with derived values
    has_error, error_message, error_type,
    -- Status fields
    compression_status, blob_status, blob_key, sync_priority,
    -- Sync tracking (new fields)
    last_sync_attempt_at, sync_attempt_count,
    -- Standard tracking
    created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id
)
SELECT 
    id, related_table, related_id, temp_related_id, type_id, original_filename,
    file_path, compressed_file_path, compressed_size_bytes, field_identifier,
    title, description, mime_type, size_bytes,
    -- Derive error state from file_path
    CASE WHEN file_path = 'ERROR' THEN 1 ELSE 0 END as has_error,
    -- Use description as error_message for existing error records
    CASE WHEN file_path = 'ERROR' THEN description ELSE NULL END as error_message,
    -- Default error type for existing errors
    CASE WHEN file_path = 'ERROR' THEN 'upload_failure' ELSE NULL END as error_type,
    -- Status fields
    compression_status, 
    'pending' as blob_status, -- Default value since column doesn't exist
    NULL as blob_key, 
    'normal' as sync_priority, -- Default value
    -- New sync tracking fields
    NULL as last_sync_attempt_at, 0 as sync_attempt_count,
    -- Standard tracking
    created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id
FROM media_documents;

-- Drop old table and rename new one
DROP TABLE media_documents;
ALTER TABLE media_documents_new RENAME TO media_documents;

-- Recreate indices for media_documents
CREATE INDEX idx_media_documents_related ON media_documents(related_table, related_id);
CREATE INDEX idx_media_documents_temp_related_id ON media_documents(temp_related_id) 
    WHERE temp_related_id IS NOT NULL;
CREATE INDEX idx_media_documents_type ON media_documents(type_id);
CREATE INDEX idx_media_documents_compression ON media_documents(compression_status);
CREATE INDEX idx_media_documents_blob_sync ON media_documents(blob_status);
CREATE INDEX idx_media_documents_updated_at ON media_documents(updated_at);
CREATE INDEX idx_media_documents_deleted_at ON media_documents(deleted_at);
CREATE INDEX idx_media_documents_sync_priority ON media_documents(sync_priority);
CREATE INDEX idx_media_documents_has_error ON media_documents(has_error);

-- ========================================================================
-- 3. Enhance document_access_logs to support more access types
-- ========================================================================

-- Update document_access_logs check constraint to support more access types
CREATE TABLE document_access_logs_new (
    id TEXT PRIMARY KEY,
    document_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    access_type TEXT NOT NULL,
    access_date TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    details TEXT,
    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Copy existing data
INSERT INTO document_access_logs_new SELECT * FROM document_access_logs;

-- Drop old table and rename new one
DROP TABLE document_access_logs;
ALTER TABLE document_access_logs_new RENAME TO document_access_logs;

-- Recreate indices
CREATE INDEX idx_document_access_logs_document ON document_access_logs(document_id);
CREATE INDEX idx_document_access_logs_user ON document_access_logs(user_id);
CREATE INDEX idx_document_access_logs_date ON document_access_logs(access_date);
CREATE INDEX idx_document_access_logs_type ON document_access_logs(access_type);

-- ========================================================================
-- 4. Create active_file_usage table for tracking files in use
-- ========================================================================

CREATE TABLE active_file_usage (
    id TEXT PRIMARY KEY,
    document_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    device_id TEXT NOT NULL,
    started_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    last_active_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    use_type TEXT NOT NULL DEFAULT 'view',
    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(document_id, user_id, device_id)
);

CREATE INDEX idx_active_file_usage_document ON active_file_usage(document_id);
CREATE INDEX idx_active_file_usage_user ON active_file_usage(user_id);
CREATE INDEX idx_active_file_usage_active ON active_file_usage(last_active_at);

-- ========================================================================
-- 5. Create file_deletion_queue for deferred file cleanup
-- ========================================================================

CREATE TABLE file_deletion_queue (
    id TEXT PRIMARY KEY,
    document_id TEXT NOT NULL,        -- For reference, even after document record deleted
    file_path TEXT NOT NULL,          -- Original file to delete
    compressed_file_path TEXT NULL,   -- Compressed version if it exists
    requested_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    requested_by TEXT NOT NULL,
    grace_period_seconds INTEGER DEFAULT 86400,  -- 24 hours by default
    attempts INTEGER DEFAULT 0,
    last_attempt_at TEXT NULL,
    completed_at TEXT NULL,
    error_message TEXT NULL,
    FOREIGN KEY (requested_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX idx_file_deletion_queue_pending ON file_deletion_queue(requested_at)
    WHERE completed_at IS NULL;
CREATE INDEX idx_file_deletion_queue_document ON file_deletion_queue(document_id);

-- ========================================================================
-- 6. Update change_log to support extra document information
-- ========================================================================

-- Add document_metadata to change_log
ALTER TABLE change_log ADD COLUMN document_metadata TEXT NULL;

-- Re-enable foreign keys
PRAGMA foreign_keys=on;





new migration 



-- Document Handling System Enhancement Migration
-- Created: April 24, 2025
-- Description: Enhances document tracking, deletion, and error handling capabilities
-- Compatible with SQLite limitations

-- Disable foreign keys during migration
PRAGMA foreign_keys=off;

-- ========================================================================
-- 1. Enhance the tombstones table with additional metadata
-- ========================================================================

-- Add additional_metadata column to tombstones
ALTER TABLE tombstones ADD COLUMN additional_metadata TEXT NULL;

-- ========================================================================
-- 2. Enhance media_documents table with error handling fields
-- ========================================================================

-- First check what columns exist in the current table
PRAGMA table_info(media_documents);

-- Create a new media_documents table with enhanced error fields and cleanup
CREATE TABLE media_documents_new (
    id TEXT PRIMARY KEY NOT NULL,
    related_table TEXT NOT NULL,
    related_id TEXT NULL,           -- Nullable to support temporary documents
    temp_related_id TEXT NULL,      -- For documents uploaded before entity creation
    type_id TEXT NOT NULL,
    original_filename TEXT NOT NULL,
    file_path TEXT NOT NULL,
    compressed_file_path TEXT NULL,
    compressed_size_bytes INTEGER NULL,
    field_identifier TEXT NULL,     -- For linking to specific form fields
    title TEXT NULL,
    description TEXT NULL,
    mime_type TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    
    -- Error handling fields
    has_error INTEGER NOT NULL DEFAULT 0,       -- Boolean flag for error state
    error_message TEXT NULL,                    -- Error details
    error_type TEXT NULL CHECK(error_type IS NULL OR error_type IN (
        'storage_failure',          -- File system errors
        'conversion_failure',       -- Format conversion errors
        'compression_failure',      -- Compression errors
        'sync_failure',             -- Sync-related errors
        'permission_failure',       -- Access permission issues
        'upload_failure',           -- Initial upload failures
        'other'                     -- Miscellaneous errors
    )),
    
    -- Status fields
    compression_status TEXT NOT NULL DEFAULT 'pending',
    blob_status TEXT NOT NULL DEFAULT 'pending',
    blob_key TEXT NULL,
    sync_priority TEXT NOT NULL DEFAULT 'normal' CHECK(sync_priority IN ('high', 'normal', 'low', 'never')),
    
    -- Sync tracking
    last_sync_attempt_at TEXT NULL,
    sync_attempt_count INTEGER NOT NULL DEFAULT 0,
    
    -- Standard tracking fields
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    created_by_user_id TEXT NULL,
    updated_by_user_id TEXT NULL,
    deleted_at TEXT NULL,
    deleted_by_user_id TEXT NULL,
    
    FOREIGN KEY (type_id) REFERENCES document_types(id) ON DELETE RESTRICT,
    FOREIGN KEY (created_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL,
    FOREIGN KEY (deleted_by_user_id) REFERENCES users(id) ON DELETE SET NULL
);

-- Copy existing data to the new table, handling missing columns
INSERT INTO media_documents_new (
    id, related_table, related_id, temp_related_id, type_id, original_filename,
    file_path, compressed_file_path, compressed_size_bytes, field_identifier, 
    title, description, mime_type, size_bytes, 
    -- Error fields with derived values
    has_error, error_message, error_type,
    -- Status fields
    compression_status, blob_status, blob_key, sync_priority,
    -- Sync tracking (new fields)
    last_sync_attempt_at, sync_attempt_count,
    -- Standard tracking
    created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id
)
SELECT 
    id, related_table, related_id, temp_related_id, type_id, original_filename,
    file_path, compressed_file_path, compressed_size_bytes, field_identifier,
    title, description, mime_type, size_bytes,
    -- Derive error state from file_path
    CASE WHEN file_path = 'ERROR' THEN 1 ELSE 0 END as has_error,
    -- Use description as error_message for existing error records
    CASE WHEN file_path = 'ERROR' THEN description ELSE NULL END as error_message,
    -- Default error type for existing errors
    CASE WHEN file_path = 'ERROR' THEN 'upload_failure' ELSE NULL END as error_type,
    -- Status fields
    compression_status, 
    'pending' as blob_status, -- Default value since column doesn't exist
    NULL as blob_key, 
    'normal' as sync_priority, -- Default value
    -- New sync tracking fields
    NULL as last_sync_attempt_at, 0 as sync_attempt_count,
    -- Standard tracking
    created_at, updated_at, created_by_user_id, updated_by_user_id, deleted_at, deleted_by_user_id
FROM media_documents;

-- Drop old table and rename new one
DROP TABLE media_documents;
ALTER TABLE media_documents_new RENAME TO media_documents;

-- Recreate indices for media_documents
CREATE INDEX idx_media_documents_related ON media_documents(related_table, related_id);
CREATE INDEX idx_media_documents_temp_related_id ON media_documents(temp_related_id) 
    WHERE temp_related_id IS NOT NULL;
CREATE INDEX idx_media_documents_type ON media_documents(type_id);
CREATE INDEX idx_media_documents_compression ON media_documents(compression_status);
CREATE INDEX idx_media_documents_blob_sync ON media_documents(blob_status);
CREATE INDEX idx_media_documents_updated_at ON media_documents(updated_at);
CREATE INDEX idx_media_documents_deleted_at ON media_documents(deleted_at);
CREATE INDEX idx_media_documents_sync_priority ON media_documents(sync_priority);
CREATE INDEX idx_media_documents_has_error ON media_documents(has_error);

-- ========================================================================
-- 3. Enhance document_access_logs to support more access types
-- ========================================================================

-- Update document_access_logs check constraint to support more access types
CREATE TABLE document_access_logs_new (
    id TEXT PRIMARY KEY,
    document_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    access_type TEXT NOT NULL,
    access_date TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    details TEXT,
    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Copy existing data
INSERT INTO document_access_logs_new SELECT * FROM document_access_logs;

-- Drop old table and rename new one
DROP TABLE document_access_logs;
ALTER TABLE document_access_logs_new RENAME TO document_access_logs;

-- Recreate indices
CREATE INDEX idx_document_access_logs_document ON document_access_logs(document_id);
CREATE INDEX idx_document_access_logs_user ON document_access_logs(user_id);
CREATE INDEX idx_document_access_logs_date ON document_access_logs(access_date);
CREATE INDEX idx_document_access_logs_type ON document_access_logs(access_type);

-- ========================================================================
-- 4. Create active_file_usage table for tracking files in use
-- ========================================================================

CREATE TABLE active_file_usage (
    id TEXT PRIMARY KEY,
    document_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    device_id TEXT NOT NULL,
    started_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    last_active_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    use_type TEXT NOT NULL DEFAULT 'view',
    FOREIGN KEY (document_id) REFERENCES media_documents(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(document_id, user_id, device_id)
);

CREATE INDEX idx_active_file_usage_document ON active_file_usage(document_id);
CREATE INDEX idx_active_file_usage_user ON active_file_usage(user_id);
CREATE INDEX idx_active_file_usage_active ON active_file_usage(last_active_at);

-- ========================================================================
-- 5. Create file_deletion_queue for deferred file cleanup
-- ========================================================================

CREATE TABLE file_deletion_queue (
    id TEXT PRIMARY KEY,
    document_id TEXT NOT NULL,        -- For reference, even after document record deleted
    file_path TEXT NOT NULL,          -- Original file to delete
    compressed_file_path TEXT NULL,   -- Compressed version if it exists
    requested_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    requested_by TEXT NOT NULL,
    grace_period_seconds INTEGER DEFAULT 86400,  -- 24 hours by default
    attempts INTEGER DEFAULT 0,
    last_attempt_at TEXT NULL,
    completed_at TEXT NULL,
    error_message TEXT NULL,
    FOREIGN KEY (requested_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX idx_file_deletion_queue_pending ON file_deletion_queue(requested_at)
    WHERE completed_at IS NULL;
CREATE INDEX idx_file_deletion_queue_document ON file_deletion_queue(document_id);

-- ========================================================================
-- 6. Update change_log to support extra document information
-- ========================================================================

-- Add document_metadata to change_log
ALTER TABLE change_log ADD COLUMN document_metadata TEXT NULL;

-- Re-enable foreign keys
PRAGMA foreign_keys=on;